import /.at.lang.futures;
import /.at.lang.multifutures;

import ~.data;
import ~.gameRules;

import /.at.collections.java.hashmap;
import /.at.support.timer exclude seconds, minutes, millisec;

enableFutures(false);

deftype Player;

// --- CONFIGURATION ---
def LOBBY := 0;
def PLAYING := 1;
def DELAY_START_SESSION := 5.seconds;
def MAX_PLAYERS := 4;
def MIN_PLAYERS := 2;

def log(text){ system.println("[AT] " + text); };

def UUID := jlobby.java.util.UUID;
def WeKittensApp := jlobby.weKittens.WeKittensApp;

def makeAmbientKittens() {
  def gui;

  // --- ETAT SESSION ---
  def myState := LOBBY;
  def currentSessionId := nil;
  def myUserId := UUID.randomUUID().toString();

  // --- ETAT JEU ---
  def gameModel := nil;

  // Gestion du timer
  def isTimerRunning := false;

  // Stockage Réseau
  def playersById  := HashMap.new();
  def playerStates := HashMap.new();
  def playerIdsList := [];

  // IDs des joueurs DE LA SESSION EN COURS
  def sessionPlayerIds := [];

  log("myUserId = " + myUserId);

  def broadcastMyState(newState) {
      playerIdsList.each: { |id|
          def player := playersById.get(id);
          player<-updatePlayerState(myUserId, newState);
      };
  };

  def getAvailablePlayers() {
      def candidates := [];
      playerIdsList.each: { |id|
          def state := playerStates.get(id);
          if: (state == nil) then: { state := LOBBY; };
          if: (state == LOBBY) then: {
              candidates := candidates + [ playersById.get(id) ];
          };
      };
      candidates;
  };

  def amITheLeader(opponentsRefs) {
      def iAmLeader := true;
      playerIdsList.each: { |id|
          def state := playerStates.get(id);
          if: (state == nil) then: { state := LOBBY; };
          if: (state == LOBBY) then: {
             if: ((id <=> myUserId) == -1) then: {
                iAmLeader := false;
             };
          };
      };
      iAmLeader;
  };

   def updateJavaHand(pid) {
       gui.clearHand();
       def myHand := gameModel.getHand(pid);
       if: (myHand != nil) then: {
           system.println("[GUI] Synchronisation de " + myHand.length + " cartes...");
           myHand.each: { |atCard|
               gui.addCardToHand(atCard.type, atCard.variant);
           };
       };
   };

  def updateTurnDisplay() {
      def currentPid := gameModel.getCurrentPlayer();
      def turns := gameModel.getTurnsLeft();
      def isMe := (currentPid == myUserId);

      def msg := "";
      if: isMe then: {
           msg := "Your turn | " + turns + " turns left";
      } else: {
           msg := "Not your turn !";
      };
      gui.setTurnStatus(msg, isMe);
  };

  def startSessionNow() {
      if: (myState == LOBBY) then: {

          def availablePlayers := getAvailablePlayers();
          def opponents := [];

          if: (availablePlayers.length > (MAX_PLAYERS - 1)) then: {
              opponents := [availablePlayers[1], availablePlayers[2], availablePlayers[3]];
          } else: {
              opponents := availablePlayers;
          };
          sessionPlayerIds := [myUserId];
          playerIdsList.each: { |id|
             def pRef := playersById.get(id);
             if: (opponents.contains(pRef)) then: {
                 sessionPlayerIds := sessionPlayerIds + [id];
             };
          };

          gameModel := makeGameRules(sessionPlayerIds);
          def config := gameModel.createInitialState();

          gameModel.initGame(config);

          myState := PLAYING;
          currentSessionId := UUID.randomUUID().toString();
          broadcastMyState(myState);
          updateTurnDisplay();

          updateJavaHand(myUserId);
          gui.initializeSession(sessionPlayerIds.length);
          log(">>> STARTING SESSION : " + currentSessionId);
          log(">>> Players : " + sessionPlayerIds.length);

          opponents.each: { |p|
              p<-inviteToSession(currentSessionId, myUserId, config, sessionPlayerIds);
          };

          localInterface.showMessage("Started session as Host.");
      };
  };

  def checkLobbyStatus() {
      if: (myState == LOBBY) then: {
          def availableCount := getAvailablePlayers().length;
          def totalCount := availableCount + 1;

          log("Check Lobby: " + totalCount + " available players.");
          if: (totalCount >= MAX_PLAYERS) then: {
               if: (amITheLeader(getAvailablePlayers())) then: {
                   log("Lobby full & I am Leader -> Direct Start !");
                   startSessionNow();
               } else: {
                   log("Lobby full but I am NOT Leader -> Waiting.");
               };
          } else: {
              if: (totalCount >= MIN_PLAYERS) then: {
                  if: (!isTimerRunning) then: {
                      log("Waiting for others (" + totalCount + " present)...");
                      isTimerRunning := true;

                      when: DELAY_START_SESSION elapsed: {
                          isTimerRunning := false;
                          if: (myState == LOBBY) then: {
                              def finalCount := getAvailablePlayers().length + 1;
                              if: (finalCount >= MIN_PLAYERS) then: {
                                  if: (amITheLeader(getAvailablePlayers())) then: {
                                      log("Timeout & I am Leader. Starting session.");
                                      startSessionNow();
                                  } else: {
                                      log("Timeout. I am NOT Leader. Waiting.");
                                  };
                              } else: {
                                  log("Timeout elapsed but players left.");
                              };
                          };
                      };
                  };
              };
          };
      };
  };

  def localInterface := object: {
      def playerDrewCard() {
              def decision := false;
              if: (myState == PLAYING) then: {
                   def op := isolate: {
                       def uuid := UUID.randomUUID().toString();
                       def type := "DRAW_CARD";
                       def card := nil;
                       def fromId := myUserId;
                       def sessionId := currentSessionId;
                   };
                   def isLegal := gameModel.validateMove(op);

                   if: (isLegal) then: {
                       log("Draw Validated locally. Committing...");
                       performTwoPhaseCommit(op);
                       decision := true;
                   } else: {
                       log("Draw Refused (Not your turn?).")
                   };
              } else: { log("Not in session!"); };
              decision;
            };

     // MODIFICATION : Retour à la version sans Data.
     def cardPlayed(jCard, targetInfo) {
                  def decision := false;
                  if: (myState == PLAYING) then: {
                       // Retour à l'appel direct (importé en haut du fichier)
                       def aCard := atCardFromJCard(jCard);

                       if: (aCard.type == "defuse") then: {
                           system.println("[GUI] Defuse détecté. Libération UI + Popup Async.");
                           decision := true;

                           when: 0.seconds elapsed: {
                               def max := gameModel.getDeckSize();
                               def idx := gui.askInsertionIndex(max);

                               def op := isolate: {
                                   def uuid := UUID.randomUUID().toString();
                                   def type := "DEFUSE_KITTEN";
                                   def card := aCard;
                                   def fromId := myUserId;
                                   def sessionId := currentSessionId;
                                   def insertIndex := idx;
                                   def shuffleData := [];
                               };

                               if: (gameModel.validateMove(op)) then: {
                                   performTwoPhaseCommit(op);
                               } else: {
                                   log("Defuse annulé ou invalide.");
                                   updateJavaHand(myUserId);
                               };
                           };

                       } else: {
                           // --- LOGIQUE CIBLAGE FAVOR ---
                           def targetId := nil;

                           if: (aCard.type == "favor") then: {
                               if: (targetInfo != -1) then: {
                                   def myIndex := 0;
                                   def count := sessionPlayerIds.length;
                                   def i := 0;

                                   sessionPlayerIds.each: { |pid|
                                       if: (pid == myUserId) then: { myIndex := i; };
                                       i := i + 1;
                                   };

                                   def offset := targetInfo;
                                   if: (count == 2) then: { offset := 1; };

                                   def targetIndex := (myIndex + offset) % count;
                                   targetId := sessionPlayerIds[targetIndex + 1];

                                   system.println("[FAVOR] Cible validée : " + targetId);
                               } else: {
                                   system.println("[FAVOR] Erreur cible.");
                               };
                           };

                           def seeds := [];
                           if: (aCard.type == "shuffle") then: {
                               1.to: 200 do: { |i|
                                   seeds := seeds + [jlobby.java.lang.Math.random()]
                               };
                           };

                           def op := isolate: {
                               def uuid := UUID.randomUUID().toString();
                               def type := "PLAY_CARD";
                               def card := aCard;
                               def fromId := myUserId;
                               def sessionId := currentSessionId;
                               def shuffleData := seeds;
                               def targetPlayer := targetId;
                           };

                           if: (gameModel.validateMove(op)) then: {
                               performTwoPhaseCommit(op);
                               decision := true;
                           } else: {
                               log("Move refused by local rules.");
                           };
                       };
                  } else: {
                       log("Not in a session!");
                  };
                  decision;
                };

           def showMessage(msg) { log("GUI MSG: " + msg); };
       };

  def performTwoPhaseCommit(op) {
      def voters := [];
      sessionPlayerIds.each: { |id|
          if: !(id == myUserId) then: {
              def pRef := playersById.get(id);
              if: !(pRef == nil) then: {
                  voters := voters + [pRef];
              };
          };
      };

      def futures := voters.map: { |p| p<-prepare(op)@FutureMessage };

      when: (group: futures) becomes: { |votes|
          def allAgreed := true;
          votes.each: { |v| if: (v == false) then: { allAgreed := false; }; };
          if: !(gameModel.validateMove(op)) then: { allAgreed := false; };

          if: (allAgreed) then: {
              commitLocally(op);
              voters.each: { |p| p<-commit(op) };
          } else: { log("2PC ABORTED."); };
      };
  };

 def commitLocally(op) {
       def res := gameModel.applyMove(op);
       // --- 1. PIOCHE (DRAW) ---
       if: (op.type == "DRAW_CARD") then: {

           if: (op.fromId == myUserId) then: {
               // C'est MOI

               def status := res;
               def cardObj := nil;

               try: {
                   if: (res.length == 2) then: {
                       status := res[1];
                       cardObj := res[2];
                   };
               } catch: { |e| status := res; };

               if: (status == "MUST_DEFUSE") then: {
                    def variant := "a";
                    if: (cardObj != nil) then: { variant := cardObj.variant; };
                    gui.showExplosionAlert(variant);
                    if: (cardObj != nil) then: {
                        gui.addCardToHand(cardObj.type, cardObj.variant);
                    };
                    localInterface.showMessage("DEFUSE REQUIS !");
               };

               if: ((status == "DIED").or: {status == "WINNER"}) then: {
                    def variant := "a";
                    if: (cardObj != nil) then: { variant := cardObj.variant; };
                    gui.showExplosionAlert(variant);
                    gui.showDeathMessage();
               };

               if: (status == "EMPTY") then: {
                    localInterface.showMessage("La pioche est vide !");
               };

               if: (status != "DIED") then: {
                   if: (status != "WINNER") then: {
                       if: (status != "MUST_DEFUSE") then: {
                           if: (status != "EMPTY") then: {
                               gui.addCardToHand(res.type, res.variant);
                           };
                       };
                   };
               };

           } else: {
               // ADVERSAIRE
               def status := res;
               try: { if: (res.length == 2) then: { status := res[1]; }; } catch: { |e| };

               if: ((status == "DIED").or: {status == "WINNER"}) then: {
                    markDeadOpponent(op.fromId);
                    if: (status == "WINNER") then: { gui.showWinMessage(); };
               };
           };
       };
       // --- 2. DECONNEXION ---
       if: (op.type == "PLAYER_LEFT") then: {
            localInterface.showMessage("Joueur " + op.fromId + " a quitté la partie.");
            markDeadOpponent(op.fromId);

            if: (res == "WINNER") then: {
                gui.showWinMessage();
            };
       };

       // --- 3. DEFUSE ---
       if: (op.type == "DEFUSE_KITTEN") then: {
           localInterface.showMessage("Ouf ! Bombe désamorcée par " + op.fromId);
           if: (op.fromId == myUserId) then: {
               updateJavaHand(myUserId);
           };
       };

       if: (op.type == "PLAY_CARD") then: {
                  if: !(op.fromId == myUserId) then: {
                       gui.playCardOpponent(op.card.type, op.card.variant);
                       // --- LOGIQUE FAVOR (Suis-je la cible ?) ---
                       if: (op.card.type == "favor") then: {
                           def target := op.targetPlayer;
                           // Si target est nil ou si C'EST MOI
                           if: ((target == nil).or: { target == myUserId }) then: {
                               system.println("[FAVOR] Je suis ciblé par " + op.fromId);

                               def choiceString := gui.askCardToGive();

                               if: (choiceString != nil) then: {
                                   def myHand := gameModel.getHand(myUserId);
                                   def cardToGive := nil;

                                   myHand.each: { |c|
                                       def name := c.type + " (" + c.variant + ")";
                                       if: ((cardToGive == nil).and: { name == choiceString }) then: {
                                           cardToGive := c;
                                       };
                                   };

                                   if: (cardToGive != nil) then: {
                                       def giveOp := isolate: {
                                           def uuid := UUID.randomUUID().toString();
                                           def type := "GIVE_CARD";
                                           def fromId := myUserId;
                                           def toId := op.fromId;
                                           def card := cardToGive;
                                           def sessionId := currentSessionId;
                                       };
                                       when: 1.seconds elapsed: { performTwoPhaseCommit(giveOp); };
                                   };
                               };
                           } else: {
                               system.println("[FAVOR] Ouf, ce n'est pas pour moi. Cible: " + target);
                           };
                       };
                  };
              };

       // --- 5. GIVE CARD (Pour Favor) ---
       if: (op.type == "GIVE_CARD") then: {
           localInterface.showMessage("Echange : " + op.fromId + " a donné une carte à " + op.toId);
           if: ((op.fromId == myUserId).or: { op.toId == myUserId }) then: {
               updateJavaHand(myUserId);
           };
       };

       updateTurnDisplay();
   };

     def markDeadOpponent(deadId) {
          def myIndex := -1;
          def oppIndex := -1;
          def count := sessionPlayerIds.length;

          def i := 0;
          sessionPlayerIds.each: { |pid|
              if: (pid == myUserId) then: { myIndex := i; };
              if: (pid == deadId) then: { oppIndex := i; };
              i := i + 1;
          };

          def relative := (oppIndex - myIndex + count) % count;
          if: (count == 2) then: {
              if: (relative == 1) then: { relative := 2;
            };
          };

          system.println("[GUI] Marking DEAD oppId: " + deadId + " at relative pos: " + relative);
          gui.markOpponentDead(relative);
     };

  def remoteInterface := object: {
    def getUserId() { myUserId; };
    def updatePlayerState(id, state) {
        log("UPDATE: Player " + id + " state -> " + state);
        playerStates.put(id, state);
        checkLobbyStatus();
    };

    def inviteToSession(sessionId, initiatorId, config, pList) {
        if: (myState == LOBBY) then: {
            myState := PLAYING;
            currentSessionId := sessionId;
            sessionPlayerIds := pList;

            gameModel := makeGameRules(sessionPlayerIds);
            gameModel.initGame(config);

            updateJavaHand(myUserId);
            gui.initializeSession(sessionPlayerIds.length);
            updateTurnDisplay();

            broadcastMyState(myState);
            log("INVITATION ACCEPTED from " + initiatorId);
            localInterface.showMessage("Joined session.");
        } else: {
            log("INVITATION DECLINED: Busy.");
        };
    };

    def prepare(op) { gameModel.validateMove(op); };
    def commit(op) { commitLocally(op); };
  };

  def pub := nil;
  def sub := nil;
  def goOnline() {
    pub := export: remoteInterface as: Player;

    sub := whenever: Player discovered: { |player|
         when: player<-getUserId()@FutureMessage becomes: { |id|
             if: (!(playersById.containsKey(id))) then: {
                 if: (id != myUserId) then: {
                     log("New player: " + id);
                     playersById.put(id, player);

                     if: (!playerStates.containsKey(id)) then: {
                        playerStates.put(id, LOBBY);
                     };

                     playerIdsList := playerIdsList + [id];
                     player<-updatePlayerState(myUserId, myState);
                     checkLobbyStatus();

                     whenever: player disconnected: {
                         log("Player " + id + " left.");
                         playersById.remove(id);
                         playerStates.remove(id);
                         playerIdsList := playerIdsList.filter: { |itemId| itemId != id };
                         if: ((myState == PLAYING).and: { sessionPlayerIds.contains(id) }) then: {
                             log("Active player disconnected. Removing...");
                             def op := isolate: {
                                 def type := "PLAYER_LEFT";
                                 def fromId := id;
                             };
                             commitLocally(op);
                             localInterface.showMessage("Player " + id + " disconnected.");
                         };
                     };
                 };
             };
         };
    };
  };
  def goOffline(){
    pub.cancel();
    sub.cancel();
  };

  gui := WeKittensApp.new(localInterface);
  goOnline();
  system.println("WeKittens ready. GUI: " + gui);
};

network.online();
makeAmbientKittens();