import /.at.lang.futures;
import /.at.lang.multifutures;

import ~.data;
import ~.gameRules;

import /.at.collections.java.hashmap;
import /.at.support.timer exclude seconds, minutes, millisec;

enableFutures(false);

deftype Player;

// --- CONFIGURATION ---
def LOBBY := 0;
def PLAYING := 1;
def DELAY_START_SESSION := 5.seconds;
def MAX_PLAYERS := 4;
def MIN_PLAYERS := 2;

def log(text){ system.println("[AT] " + text); };

def UUID := jlobby.java.util.UUID;
def WeKittensApp := jlobby.weKittens.WeKittensApp;

def makeAmbientKittens() {
  def gui;

  // --- ETAT SESSION ---
  def myState := LOBBY;
  def currentSessionId := nil;
  def myUserId := UUID.randomUUID().toString();

  // --- ETAT JEU ---
  def gameModel := nil;

  // Gestion du timer
  def isTimerRunning := false;

  // Stockage Réseau
  def playersById  := HashMap.new();
  def playerStates := HashMap.new();
  def playerIdsList := [];

  // IDs des joueurs DE LA SESSION EN COURS
  def sessionPlayerIds := [];

  log("myUserId = " + myUserId);

  def broadcastMyState(newState) {
      playerIdsList.each: { |id|
          def player := playersById.get(id);
          player<-updatePlayerState(myUserId, newState);
      };
  };

  def getAvailablePlayers() {
      def candidates := [];
      playerIdsList.each: { |id|
          def state := playerStates.get(id);
          if: (state == nil) then: { state := LOBBY; };
          if: (state == LOBBY) then: {
              candidates := candidates + [ playersById.get(id) ];
          };
      };
      candidates;
  };

  def amITheLeader(opponentsRefs) {
      def iAmLeader := true;
      playerIdsList.each: { |id|
          def state := playerStates.get(id);
          if: (state == nil) then: { state := LOBBY; };
          if: (state == LOBBY) then: {
             if: ((id <=> myUserId) == -1) then: {
                iAmLeader := false;
             };
          };
      };
      iAmLeader;
  };

   def updateJavaHand(pid) {
       gui.clearHand();
       def myHand := gameModel.getHand(pid);

       if: (myHand != nil) then: {
           system.println("[GUI] Synchronisation de " + myHand.length + " cartes...");
           myHand.each: { |atCard|
               gui.addCardToHand(atCard.type, atCard.variant);
           };
       };
   };

  def updateTurnDisplay() {
      def currentPid := gameModel.getCurrentPlayer();
      def turns := gameModel.getTurnsLeft();
      def isMe := (currentPid == myUserId);

      def msg := "";
      if: isMe then: {
           msg := "Your turn | " + turns + " turns left";
      } else: {
           msg := "Not your turn !";
      };

      gui.setTurnStatus(msg, isMe);
  };

  def startSessionNow() {
      if: (myState == LOBBY) then: {

          def availablePlayers := getAvailablePlayers();
          def opponents := [];

          if: (availablePlayers.length > (MAX_PLAYERS - 1)) then: {
              opponents := [availablePlayers[1], availablePlayers[2], availablePlayers[3]];
          } else: {
              opponents := availablePlayers;
          };

          sessionPlayerIds := [myUserId];
          playerIdsList.each: { |id|
             def pRef := playersById.get(id);
             if: (opponents.contains(pRef)) then: {
                 sessionPlayerIds := sessionPlayerIds + [id];
             };
          };

          gameModel := makeGameRules(sessionPlayerIds);
          def config := gameModel.createInitialState();

          gameModel.initGame(config);

          myState := PLAYING;
          currentSessionId := UUID.randomUUID().toString();
          broadcastMyState(myState);
          updateTurnDisplay();

          updateJavaHand(myUserId);
          gui.initializeSession(sessionPlayerIds.length);

          log(">>> STARTING SESSION : " + currentSessionId);
          log(">>> Players : " + sessionPlayerIds.length);

          opponents.each: { |p|
              p<-inviteToSession(currentSessionId, myUserId, config, sessionPlayerIds);
          };

          localInterface.showMessage("Started session as Host.");
      };
  };

  def checkLobbyStatus() {
      if: (myState == LOBBY) then: {
          def availableCount := getAvailablePlayers().length;
          def totalCount := availableCount + 1;

          log("Check Lobby: " + totalCount + " available players.");

          if: (totalCount >= MAX_PLAYERS) then: {
               if: (amITheLeader(getAvailablePlayers())) then: {
                   log("Lobby full & I am Leader -> Direct Start !");
                   startSessionNow();
               } else: {
                   log("Lobby full but I am NOT Leader -> Waiting.");
               };
          } else: {
              if: (totalCount >= MIN_PLAYERS) then: {
                  if: (!isTimerRunning) then: {
                      log("Waiting for others (" + totalCount + " present)...");
                      isTimerRunning := true;

                      when: DELAY_START_SESSION elapsed: {
                          isTimerRunning := false;
                          if: (myState == LOBBY) then: {
                              def finalCount := getAvailablePlayers().length + 1;
                              if: (finalCount >= MIN_PLAYERS) then: {
                                  if: (amITheLeader(getAvailablePlayers())) then: {
                                      log("Timeout & I am Leader. Starting session.");
                                      startSessionNow();
                                  } else: {
                                      log("Timeout. I am NOT Leader. Waiting.");
                                  };
                              } else: {
                                  log("Timeout elapsed but players left.");
                              };
                          };
                      };
                  };
              };
          };
      };
  };

  def localInterface := object: {
      def playerDrewCard() {
              def decision := false;
              if: (myState == PLAYING) then: {
                   def op := isolate: {
                       def uuid := UUID.randomUUID().toString();
                       def type := "DRAW_CARD";
                       def card := nil;
                       def fromId := myUserId;
                       def sessionId := currentSessionId;
                   };

                   def isLegal := gameModel.validateMove(op);

                   if: (isLegal) then: {
                       log("Draw Validated locally. Committing...");
                       performTwoPhaseCommit(op);
                       decision := true;
                   } else: {
                       log("Draw Refused (Not your turn?).")
                   };
              } else: { log("Not in session!"); };
              decision;
            };

     def cardPlayed(jCard) {
             def decision := false;

             if: (myState == PLAYING) then: {
                  def aCard := atCardFromJCard(jCard);

                  if: (aCard.type == "defuse") then: {
                      system.println("[GUI] Defuse détecté. Libération UI + Popup Async.");
                      decision := true;

                      when: 0.seconds elapsed: {
                          def max := gameModel.getDeckSize();
                          def idx := gui.askInsertionIndex(max);

                          def op := isolate: {
                              def uuid := UUID.randomUUID().toString();
                              def type := "DEFUSE_KITTEN";
                              def card := aCard;
                              def fromId := myUserId;
                              def sessionId := currentSessionId;
                              def insertIndex := idx;
                              def shuffleData := [];
                          };

                          if: (gameModel.validateMove(op)) then: {
                              performTwoPhaseCommit(op);
                          } else: {
                              log("Defuse annulé ou invalide.");
                              updateJavaHand(myUserId);
                          };
                      };

                  } else: {
                      def seeds := [];
                      if: (aCard.type == "shuffle") then: {
                          system.println("[GUI] Génération des graines pour Shuffle...");
                          1.to: 200 do: { |i| seeds := seeds + [jlobby.java.lang.Math.random()] };
                      };

                      def op := isolate: {
                          def uuid := UUID.randomUUID().toString();
                          def type := "PLAY_CARD";
                          def card := aCard;
                          def fromId := myUserId;
                          def sessionId := currentSessionId;
                          def shuffleData := seeds;
                      };

                      if: (gameModel.validateMove(op)) then: {
                          performTwoPhaseCommit(op);
                          decision := true;
                      } else: {
                          log("Move refused by local rules.");
                      };
                  };
             } else: {
                  log("Not in a session!");
             };

             decision;
           };

           def showMessage(msg) { log("GUI MSG: " + msg); };
       };

  def performTwoPhaseCommit(op) {
      def voters := [];
      sessionPlayerIds.each: { |id|
          if: !(id == myUserId) then: {
              def pRef := playersById.get(id);
              if: !(pRef == nil) then: {
                  voters := voters + [pRef];
              };
          };
      };

      def futures := voters.map: { |p| p<-prepare(op)@FutureMessage };

      when: (group: futures) becomes: { |votes|
          def allAgreed := true;
          votes.each: { |v| if: (v == false) then: { allAgreed := false; }; };

          if: !(gameModel.validateMove(op)) then: { allAgreed := false; };

          if: (allAgreed) then: {
              commitLocally(op);
              voters.each: { |p| p<-commit(op) };
          } else: { log("2PC ABORTED."); };
      };
  };

 def commitLocally(op) {
       def res := gameModel.applyMove(op);

       // --- 1. PIOCHE (DRAW) ---
       if: (op.type == "DRAW_CARD") then: {

           if: (op.fromId == myUserId) then: {
               // C'est MOI

               def status := res;
               def cardObj := nil;

               // Extraction sûre du résultat complexe
               try: {
                   if: (res.length == 2) then: {
                       status := res[1];
                       cardObj := res[2];
                   };
               } catch: { |e| status := res; };

               if: (status == "MUST_DEFUSE") then: {
                    // On passe la vraie variante à l'UI
                    def variant := "a";
                    if: (cardObj != nil) then: { variant := cardObj.variant; };
                    gui.showExplosionAlert(variant);

                    if: (cardObj != nil) then: {
                        gui.addCardToHand(cardObj.type, cardObj.variant);
                    };
                    localInterface.showMessage("DEFUSE REQUIS !");
               };

               if: ((status == "DIED").or: {status == "WINNER"}) then: {
                    def variant := "a";
                    if: (cardObj != nil) then: { variant := cardObj.variant; };
                    gui.showExplosionAlert(variant);
                    gui.showDeathMessage();
               };

               if: (status == "EMPTY") then: {
                    localInterface.showMessage("La pioche est vide !");
               };

               // --- CORRECTION CRITIQUE ICI : NESTED IFS ---
               // On remplace le "and:" chaîné par des if imbriqués
               if: (status != "DIED") then: {
                   if: (status != "WINNER") then: {
                       if: (status != "MUST_DEFUSE") then: {
                           if: (status != "EMPTY") then: {
                                // Ici res est directement la carte (comportement standard)
                                gui.addCardToHand(res.type, res.variant);
                           };
                       };
                   };
               };

           } else: {
               // ADVERSAIRE
               def status := res;
               try: { if: (res.length == 2) then: { status := res[1]; }; } catch: { |e| };

               if: ((status == "DIED").or: {status == "WINNER"}) then: {
                    markDeadOpponent(op.fromId);
                    if: (status == "WINNER") then: { gui.showWinMessage(); };
               };
           };
       };

       // --- 2. DECONNEXION ---
       if: (op.type == "PLAYER_LEFT") then: {
            localInterface.showMessage("Joueur " + op.fromId + " a quitté la partie.");
            markDeadOpponent(op.fromId);

            if: (res == "WINNER") then: {
                gui.showWinMessage();
            };
       };

       // --- 3. DEFUSE ---
       if: (op.type == "DEFUSE_KITTEN") then: {
           localInterface.showMessage("Ouf ! Bombe désamorcée par " + op.fromId);
           if: (op.fromId == myUserId) then: {
               updateJavaHand(myUserId);
           };
       };

       // --- 4. PLAY CARD ---
       if: (op.type == "PLAY_CARD") then: {
           if: !(op.fromId == myUserId) then: {
                gui.playCardOpponent(op.card.type, op.card.variant);
           };
       };

       updateTurnDisplay();
   };

     def markDeadOpponent(deadId) {
          def myIndex := 0;
          def oppIndex := 0;
          def count := sessionPlayerIds.length;

          0.to: (count - 1) do: { |i|
              if: (sessionPlayerIds[i+1] == myUserId) then: { myIndex := i; };
              if: (sessionPlayerIds[i+1] == deadId) then: { oppIndex := i; };
          };

          def relative := (oppIndex - myIndex + count) % count;

          if: (count == 2) then: {
              if: (relative == 1) then: { relative := 2; };
          };

          system.println("[GUI] Marking DEAD oppId: " + deadId + " at relative pos: " + relative);
          gui.markOpponentDead(relative);
     };

  def remoteInterface := object: {
    def getUserId() { myUserId; };

    def updatePlayerState(id, state) {
        log("UPDATE: Player " + id + " state -> " + state);
        playerStates.put(id, state);
        checkLobbyStatus();
    };

    def inviteToSession(sessionId, initiatorId, config, pList) {
        if: (myState == LOBBY) then: {
            myState := PLAYING;
            currentSessionId := sessionId;
            sessionPlayerIds := pList;

            gameModel := makeGameRules(sessionPlayerIds);
            gameModel.initGame(config);

            updateJavaHand(myUserId);
            gui.initializeSession(sessionPlayerIds.length);
            updateTurnDisplay();

            broadcastMyState(myState);
            log("INVITATION ACCEPTED from " + initiatorId);
            localInterface.showMessage("Joined session.");
        } else: {
            log("INVITATION DECLINED: Busy.");
        };
    };

    def prepare(op) { gameModel.validateMove(op); };
    def commit(op) { commitLocally(op); };
  };

  def pub := nil;
  def sub := nil;

  def goOnline() {
    pub := export: remoteInterface as: Player;

    sub := whenever: Player discovered: { |player|
         when: player<-getUserId()@FutureMessage becomes: { |id|
             if: (!(playersById.containsKey(id))) then: {
                 if: (id != myUserId) then: {
                     log("New player: " + id);
                     playersById.put(id, player);

                     if: (!playerStates.containsKey(id)) then: {
                        playerStates.put(id, LOBBY);
                     };

                     playerIdsList := playerIdsList + [id];
                     player<-updatePlayerState(myUserId, myState);
                     checkLobbyStatus();

                     whenever: player disconnected: {
                         log("Player " + id + " left.");
                         playersById.remove(id);
                         playerStates.remove(id);
                         playerIdsList := playerIdsList.filter: { |itemId| itemId != id };

                         if: ((myState == PLAYING).and: { sessionPlayerIds.contains(id) }) then: {
                             log("Active player disconnected. Removing...");
                             def op := isolate: {
                                 def type := "PLAYER_LEFT";
                                 def fromId := id;
                             };
                             commitLocally(op);
                             localInterface.showMessage("Player " + id + " disconnected.");
                         };
                     };
                 };
             };
         };
    };
  };

  def goOffline(){
    pub.cancel();
    sub.cancel();
  };

  gui := WeKittensApp.new(localInterface);
  goOnline();
  system.println("WeKittens ready. GUI: " + gui);
};

network.online();
makeAmbientKittens();