import /.at.lang.futures;
import /.at.lang.multifutures;

import ~.data;
import ~.gameRules;

import /.at.collections.java.hashmap;
import /.at.support.timer exclude seconds, minutes, millisec;

enableFutures(false);

deftype Player;

// --- CONFIGURATION ---
def LOBBY := 0;
def PLAYING := 1;
def DELAY_START_SESSION := 5.seconds;
def MAX_PLAYERS := 4;
def MIN_PLAYERS := 2;

def log(text){ system.println("[AT] " + text); };

def UUID := jlobby.java.util.UUID;
def WeKittensApp := jlobby.weKittens.WeKittensApp;

def makeAmbientKittens() {
  def gui;

  // --- ETAT SESSION ---
  def myState := LOBBY;
  def currentSessionId := nil;
  def myUserId := UUID.randomUUID().toString();

  // --- ETAT JEU ---
  def gameModel := nil;

  // Gestion du timer
  def isTimerRunning := false;

  // Stockage Réseau
  def playersById  := HashMap.new();
  def playerStates := HashMap.new();
  def playerIdsList := [];

  // IDs des joueurs DE LA SESSION EN COURS
  def sessionPlayerIds := [];

  log("myUserId = " + myUserId);

  def broadcastMyState(newState) {
      playerIdsList.each: { |id|
          def player := playersById.get(id);
          player<-updatePlayerState(myUserId, newState);
      };
  };

  def getAvailablePlayers() {
      def candidates := [];
      playerIdsList.each: { |id|
          def state := playerStates.get(id);
          if: (state == nil) then: { state := LOBBY; };
          if: (state == LOBBY) then: {
              candidates := candidates + [ playersById.get(id) ];
          };
      };
      candidates;
  };

  def amITheLeader(opponentsRefs) {
      def iAmLeader := true;
      playerIdsList.each: { |id|
          def state := playerStates.get(id);
          if: (state == nil) then: { state := LOBBY; };
          if: (state == LOBBY) then: {
             if: ((id <=> myUserId) == -1) then: {
                iAmLeader := false;
             };
          };
      };
      iAmLeader;
  };

   def updateJavaHand(pid) {
       gui.clearHand();
       def myHand := gameModel.getHand(pid);
       if: (myHand != nil) then: {
           system.println("[GUI] Synchronisation de " + myHand.length + " cartes...");
           myHand.each: { |atCard|
               gui.addCardToHand(atCard.type, atCard.variant);
           };
       };
   };

  def updateTurnDisplay() {
      def currentPid := gameModel.getCurrentPlayer();
      def turns := gameModel.getTurnsLeft();
      def isMe := (currentPid == myUserId);

      def msg := "";
      if: isMe then: {
           msg := "Your turn | " + turns + " turns left";
      } else: {
           msg := "Not your turn !";
      };
      gui.setTurnStatus(msg, isMe);
  };

  def startSessionNow() {
      if: (myState == LOBBY) then: {

          def availablePlayers := getAvailablePlayers();
          def opponents := [];

          if: (availablePlayers.length > (MAX_PLAYERS - 1)) then: {
              opponents := [availablePlayers[1], availablePlayers[2], availablePlayers[3]];
          } else: {
              opponents := availablePlayers;
          };

          sessionPlayerIds := [myUserId];
          playerIdsList.each: { |id|
             def pRef := playersById.get(id);
             if: (opponents.contains(pRef)) then: {
                 sessionPlayerIds := sessionPlayerIds + [id];
             };
          };

          gameModel := makeGameRules(sessionPlayerIds);
          def config := gameModel.createInitialState();

          gameModel.initGame(config);

          myState := PLAYING;
          currentSessionId := UUID.randomUUID().toString();
          broadcastMyState(myState);
          updateTurnDisplay();

          updateJavaHand(myUserId);
          gui.initializeSession(sessionPlayerIds.length);

          log(">>> STARTING SESSION : " + currentSessionId);
          log(">>> Players : " + sessionPlayerIds.length);

          opponents.each: { |p|
              p<-inviteToSession(currentSessionId, myUserId, config, sessionPlayerIds);
          };

          localInterface.showMessage("Started session as Host.");
      };
  };

  def checkLobbyStatus() {
      if: (myState == LOBBY) then: {
          def availableCount := getAvailablePlayers().length;
          def totalCount := availableCount + 1;

          log("Check Lobby: " + totalCount + " available players.");

          if: (totalCount >= MAX_PLAYERS) then: {
               if: (amITheLeader(getAvailablePlayers())) then: {
                   log("Lobby full & I am Leader -> Direct Start !");
                   startSessionNow();
               } else: {
                   log("Lobby full but I am NOT Leader -> Waiting.");
               };
          } else: {
              if: (totalCount >= MIN_PLAYERS) then: {
                  if: (!isTimerRunning) then: {
                      log("Waiting for others (" + totalCount + " present)...");
                      isTimerRunning := true;

                      when: DELAY_START_SESSION elapsed: {
                          isTimerRunning := false;
                          if: (myState == LOBBY) then: {
                              def finalCount := getAvailablePlayers().length + 1;
                              if: (finalCount >= MIN_PLAYERS) then: {
                                  if: (amITheLeader(getAvailablePlayers())) then: {
                                      log("Timeout & I am Leader. Starting session.");
                                      startSessionNow();
                                  } else: {
                                      log("Timeout. I am NOT Leader. Waiting.");
                                  };
                              } else: {
                                  log("Timeout elapsed but players left.");
                              };
                          };
                      };
                  };
              };
          };
      };
  };

  def localInterface := object: {
      def playerDrewCard() {
              def decision := false;
              if: (myState == PLAYING) then: {
                   def op := isolate: {
                       def uuid := UUID.randomUUID().toString();
                       def type := "DRAW_CARD";
                       def card := nil;
                       def fromId := myUserId;
                       def sessionId := currentSessionId;
                   };

                   def isLegal := gameModel.validateMove(op);

                   if: (isLegal) then: {
                       log("Draw Validated locally. Committing...");
                       performTwoPhaseCommit(op);
                       decision := true;
                   } else: {
                       log("Draw Refused (Not your turn?).")
                   };
              } else: { log("Not in session!"); };
              decision;
            };

      // FONCTION UTILITAIRE : Conversion Relative -> ID
           def getTargetIdFromRelative(targetRel) {
                 def targetId := nil;
                 if: (targetRel != -1) then: {
                       def myIndex := 0;
                       def count := sessionPlayerIds.length;
                       def i := 0;
                       sessionPlayerIds.each: { |pid|
                           if: (pid == myUserId) then: { myIndex := i; };
                           i := i + 1;
                       };
                       def offset := targetRel;
                       if: (count == 2) then: { offset := 1; };
                       def targetIndex := (myIndex + offset) % count;
                       targetId := sessionPlayerIds[targetIndex + 1];
                 };
                 targetId;
           };

           // Récupère la taille réelle de la main
           def getOpponentHandSize(targetRel) {
               def size := 1;
               if: (myState == PLAYING) then: {
                   def targetId := getTargetIdFromRelative(targetRel);
                   if: (targetId != nil) then: {
                       def hand := gameModel.getHand(targetId);
                       if: (hand != nil) then: {
                           size := hand.length;
                           system.println("[CHEAT] Taille main cible (" + targetId + ") : " + size);
                       };
                   };
               };
               size;
           };

           // PAIR PLAYED
           def pairPlayed(jCard, targetRel, stealIdx) {
               def decision := false;
               if: (myState == PLAYING) then: {
                   def aCard := atCardFromJCard(jCard);
                   def targetId := getTargetIdFromRelative(targetRel);

                   if: (targetId != nil) then: {
                       system.println("[PAIR] Playing pair on " + targetId + " index " + stealIdx);
                       def op := isolate: {
                           def uuid := UUID.randomUUID().toString();
                           def type := "PLAY_PAIR";
                           def card := aCard;
                           def fromId := myUserId;
                           def sessionId := currentSessionId;
                           def targetPlayer := targetId;
                           def stealIndex := stealIdx;
                       };

                       if: (gameModel.validateMove(op)) then: {
                           performTwoPhaseCommit(op);
                           decision := true;
                       } else: {
                           log("Pair move refused.");
                       };
                   };
               };
               decision;
           };

           // TRIPLE PLAYED
           def triplePlayed(jCard, targetRel, rType, rVar) {
                    def decision := false;
                    if: (myState == PLAYING) then: {
                        def aCard := atCardFromJCard(jCard);
                        def targetId := getTargetIdFromRelative(targetRel);

                        if: (targetId != nil) then: {
                            system.println("[TRIPLE] Asking " + targetId + " for " + rType + " (" + rVar + ")");
                            def op := isolate: {
                                def uuid := UUID.randomUUID().toString();
                                def type := "PLAY_TRIPLE";
                                def card := aCard;
                                def fromId := myUserId;
                                def sessionId := currentSessionId;
                                def targetPlayer := targetId;
                                def reqType := rType;
                                def reqVariant := rVar;
                            };

                            if: (gameModel.validateMove(op)) then: {
                                performTwoPhaseCommit(op);
                                decision := true;
                            } else: {
                                log("Triple move refused.");
                            };
                        };
                    };
                    decision;
                };

           // NOUVEAU : COMBO 5 CARTES
           def special5ComboPlayed() {
               def decision := false;
               if: (myState == PLAYING) then: {
                   def op := isolate: {
                       def uuid := UUID.randomUUID().toString();
                       def type := "PLAY_SPECIAL_5";
                       def fromId := myUserId;
                       def sessionId := currentSessionId;
                       def card := nil;
                   };

                   if: (gameModel.validateMove(op)) then: {
                       performTwoPhaseCommit(op);
                       decision := true;
                   } else: {
                       log("Special 5 combo refused.");
                   };
               };
               decision;
           };

           // NOUVEAU : RECUPERER DEPUIS DEFAUSSE
           def pickFromDiscard(cType, cVar) {
               def decision := false;
               if: (myState == PLAYING) then: {
                   def targetCard := atCard.new(cType, cVar);

                   def op := isolate: {
                       def uuid := UUID.randomUUID().toString();
                       def type := "TAKE_DISCARD";
                       def fromId := myUserId;
                       def sessionId := currentSessionId;
                       def card := targetCard;
                   };

                   if: (gameModel.validateMove(op)) then: {
                       performTwoPhaseCommit(op);
                       decision := true;
                   } else: {
                       log("Pick from discard refused.");
                   };
               };
               decision;
           };

           def cardPlayed(jCard, targetInfo) {
                  def decision := false;
                  if: (myState == PLAYING) then: {
                       def aCard := atCardFromJCard(jCard);

                       if: (aCard.type == "defuse") then: {
                           system.println("[GUI] Defuse détecté. Libération UI + Popup Async.");
                           decision := true;

                           when: 0.seconds elapsed: {
                               def max := gameModel.getDeckSize();
                               def idx := gui.askInsertionIndex(max);

                               def op := isolate: {
                                   def uuid := UUID.randomUUID().toString();
                                   def type := "DEFUSE_KITTEN";
                                   def card := aCard;
                                   def fromId := myUserId;
                                   def sessionId := currentSessionId;
                                   def insertIndex := idx;
                                   def shuffleData := [];
                               };

                               if: (gameModel.validateMove(op)) then: {
                                   performTwoPhaseCommit(op);
                               } else: {
                                   log("Defuse annulé ou invalide.");
                                   updateJavaHand(myUserId);
                               };
                           };

                       } else: {
                           // --- LOGIQUE CIBLAGE FAVOR ---
                           def targetId := nil;
                           if: (aCard.type == "favor") then: {
                               if: (targetInfo != -1) then: {
                                   def myIndex := 0;
                                   def count := sessionPlayerIds.length;
                                   def i := 0;

                                   sessionPlayerIds.each: { |pid|
                                       if: (pid == myUserId) then: { myIndex := i; };
                                       i := i + 1;
                                   };

                                   def offset := targetInfo;
                                   if: (count == 2) then: { offset := 1; };

                                   def targetIndex := (myIndex + offset) % count;
                                   targetId := sessionPlayerIds[targetIndex + 1];
                                   system.println("[FAVOR] Cible validée : " + targetId);
                               } else: {
                                   system.println("[FAVOR] Erreur cible.");
                               };
                           };

                           def seeds := [];
                           if: (aCard.type == "shuffle") then: {
                               1.to: 200 do: { |i|
                                   seeds := seeds + [jlobby.java.lang.Math.random()]
                               };
                           };

                           def op := isolate: {
                               def uuid := UUID.randomUUID().toString();
                               def type := "PLAY_CARD";
                               def card := aCard;
                               def fromId := myUserId;
                               def sessionId := currentSessionId;
                               def shuffleData := seeds;
                               def targetPlayer := targetId;
                           };

                           if: (gameModel.validateMove(op)) then: {
                               performTwoPhaseCommit(op);
                               decision := true;
                           } else: {
                               log("Move refused by local rules.");
                           };
                       };
                  } else: {
                       log("Not in a session!");
                  };
                  decision;
                };

           def showMessage(msg) { log("GUI MSG: " + msg); };
       };

  def performTwoPhaseCommit(op) {
      def voters := [];
      sessionPlayerIds.each: { |id|
          if: !(id == myUserId) then: {
              def pRef := playersById.get(id);
              if: !(pRef == nil) then: {
                  voters := voters + [pRef];
              };
          };
      };

      def futures := voters.map: { |p| p<-prepare(op)@FutureMessage };

      when: (group: futures) becomes: { |votes|
          def allAgreed := true;
          votes.each: { |v| if: (v == false) then: { allAgreed := false; }; };
          if: !(gameModel.validateMove(op)) then: { allAgreed := false; };

          if: (allAgreed) then: {
              commitLocally(op);
              voters.each: { |p| p<-commit(op) };
          } else: { log("2PC ABORTED."); };
      };
  };

  def commitLocally(op) {
       def res := gameModel.applyMove(op);

       // --- 1. PIOCHE (DRAW) ---
       if: (op.type == "DRAW_CARD") then: {

           if: (op.fromId == myUserId) then: {
               // C'est MOI
               def status := res;
               def cardObj := nil;

               try: {
                   if: (res.length == 2) then: {
                       status := res[1];
                       cardObj := res[2];
                   };
               } catch: { |e| status := res; };

               if: (status == "MUST_DEFUSE") then: {
                    def variant := "a";
                    if: (cardObj != nil) then: { variant := cardObj.variant; };
                    gui.showExplosionAlert(variant);
                    if: (cardObj != nil) then: {
                        gui.addCardToHand(cardObj.type, cardObj.variant);
                    };
                    localInterface.showMessage("DEFUSE REQUIS !");
               };

               if: ((status == "DIED").or: {status == "WINNER"}) then: {
                    def variant := "a";
                    if: (cardObj != nil) then: { variant := cardObj.variant; };
                    gui.showExplosionAlert(variant);
                    gui.showDeathMessage();

                    // [FIX] Afficher le dessus de la pile (cartes du mort)
                    def top := gameModel.getDiscardTop();
                    if: (top != nil) then: { gui.playCardOpponent(top.type, top.variant); };
               };

               if: (status == "EMPTY") then: {
                    localInterface.showMessage("La pioche est vide !");
               };

               if: (status != "DIED") then: {
                   if: (status != "WINNER") then: {
                       if: (status != "MUST_DEFUSE") then: {
                           if: (status != "EMPTY") then: {
                               gui.addCardToHand(res.type, res.variant);
                           };
                       };
                   };
               };

           } else: {
               // ADVERSAIRE
               def status := res;
               try: { if: (res.length == 2) then: { status := res[1]; }; } catch: { |e| };
               if: ((status == "DIED").or: {status == "WINNER"}) then: {
                    markDeadOpponent(op.fromId);

                    // [FIX] Afficher le dessus de la pile pour adversaires
                    def top := gameModel.getDiscardTop();
                    if: (top != nil) then: { gui.playCardOpponent(top.type, top.variant); };

                    if: (status == "WINNER") then: { gui.showWinMessage(); };
               };
           };
       };

       // --- 2. DECONNEXION ---
       if: (op.type == "PLAYER_LEFT") then: {
            localInterface.showMessage("Joueur " + op.fromId + " a quitté la partie.");
            markDeadOpponent(op.fromId);

            // [FIX] Afficher le dessus de la pile
            def top := gameModel.getDiscardTop();
            if: (top != nil) then: { gui.playCardOpponent(top.type, top.variant); };

            if: (res == "WINNER") then: {
                gui.showWinMessage();
            };
       };

       // --- 3. DEFUSE ---
       if: (op.type == "DEFUSE_KITTEN") then: {
           localInterface.showMessage("Ouf ! Bombe désamorcée par " + op.fromId);

           // [FIX] Visuel pour adversaires
           if: (op.fromId != myUserId) then: {
                gui.playCardOpponent(op.card.type, op.card.variant);
           };

           if: (op.fromId == myUserId) then: {
               updateJavaHand(myUserId);
           };
       };

       // --- 4. PLAY CARD ---
       if: (op.type == "PLAY_CARD") then: {

           // --- CAS A : C'est MOI qui joue ---
           if: (op.fromId == myUserId) then: {

               // Vérification si c'est "SEE THE FUTURE"
               def status := res;
               def peekCards := [];

               try: {
                   if: (res.length == 2) then: {
                       status := res[1];
                       peekCards := res[2];
                   };
               } catch: { |e| status := res; };

               if: (status == "PEEK_FUTURE") then: {
                    system.println("[FUTURE] Affichage des 3 cartes...");
                    def typesList := jlobby.java.util.ArrayList.new();
                    def varsList := jlobby.java.util.ArrayList.new();

                    peekCards.each: { |c|
                        typesList.add(c.type);
                        varsList.add(c.variant);
                    };

                    gui.showSeeTheFuture(typesList, varsList);
               };
           } else: {
               // --- CAS B : C'est l'ADVERSAIRE qui joue ---
               gui.playCardOpponent(op.card.type, op.card.variant);

               // --- LOGIQUE FAVOR (Suis-je la cible ?) ---
               if: (op.card.type == "favor") then: {
                   def target := op.targetPlayer;
                   if: ((target == nil).or: { target == myUserId }) then: {
                       system.println("[FAVOR] Je suis ciblé par " + op.fromId);
                       def choiceString := gui.askCardToGive();

                       if: (choiceString != nil) then: {
                           def myHand := gameModel.getHand(myUserId);
                           def cardToGive := nil;

                           myHand.each: { |c|
                               def name := c.type + " (" + c.variant + ")";
                               if: ((cardToGive == nil).and: { name == choiceString }) then: {
                                   cardToGive := c;
                               };
                           };

                           if: (cardToGive != nil) then: {
                               def giveOp := isolate: {
                                   def uuid := UUID.randomUUID().toString();
                                   def type := "GIVE_CARD";
                                   def fromId := myUserId;
                                   def toId := op.fromId;
                                   def card := cardToGive;
                                   def sessionId := currentSessionId;
                               };
                               when: 1.seconds elapsed: { performTwoPhaseCommit(giveOp); };
                           };
                       };
                   } else: {
                       system.println("[FAVOR] Ouf, ce n'est pas pour moi. Cible: " + target);
                   };
               };
           };
       };

       // --- 5. GIVE CARD (Pour Favor / Vol) ---
       if: (op.type == "GIVE_CARD") then: {
           localInterface.showMessage("Echange : " + op.fromId + " a donné une carte à " + op.toId);
           if: ((op.fromId == myUserId).or: { op.toId == myUserId }) then: {
               updateJavaHand(myUserId);
           };
       };

       // --- 6. PLAY PAIR ---
       if: (op.type == "PLAY_PAIR") then: {
           // [FIX VISUEL]
           if: (op.fromId != myUserId) then: {
               gui.playCardOpponent(op.card.type, op.card.variant);
           };

           // Si je suis l'attaquant
           if: (op.fromId == myUserId) then: {
               updateJavaHand(myUserId);
               localInterface.showMessage("Vol lancé sur joueur " + op.targetPlayer);
           } else: {
               // Si je suis l'attaqué (Victime)
               if: (op.targetPlayer == myUserId) then: {
                   system.println("[PAIR] On me vole une carte index " + op.stealIndex);
                   def myHand := gameModel.getHand(myUserId);
                   if: ((myHand != nil).and: { myHand.length > 0 }) then: {
                       def idx := (op.stealIndex - 1) % myHand.length;
                       def stolenCard := myHand[idx + 1];

                       localInterface.showMessage("On vous a volé : " + stolenCard.type);
                       def giveOp := isolate: {
                           def uuid := UUID.randomUUID().toString();
                           def type := "GIVE_CARD";
                           def fromId := myUserId;
                           def toId := op.fromId;
                           def card := stolenCard;
                           def sessionId := currentSessionId;
                       };
                       performTwoPhaseCommit(giveOp);
                   };
               } else: {
                   localInterface.showMessage(op.fromId + " vole une carte à " + op.targetPlayer);
               };
           };
       };

       // --- 7. PLAY TRIPLE ---
       if: (op.type == "PLAY_TRIPLE") then: {
           // [FIX VISUEL]
           if: (op.fromId != myUserId) then: {
               gui.playCardOpponent(op.card.type, op.card.variant);
           };

           // Si je suis l'attaquant
           if: (op.fromId == myUserId) then: {
               updateJavaHand(myUserId);
               log("Demande de " + op.reqType + " envoyée à " + op.targetPlayer);
           } else: {
               if: (op.targetPlayer == myUserId) then: {
                   system.println("[TRIPLE] On me demande : " + op.reqType + " / " + op.reqVariant);
                   def myHand := gameModel.getHand(myUserId);
                   def foundCard := nil;

                   if: (myHand != nil) then: {
                       myHand.each: { |c|
                           if: (foundCard == nil) then: {
                               def cType := c.type + "";
                               def cVar := c.variant + "";
                               def rType := op.reqType + "";
                               def rVar := op.reqVariant + "";
                               if: (cType == rType) then: {
                                   if: (cVar == rVar) then: {
                                       foundCard := c;
                                   };
                               };
                           };
                       };
                   };
                   if: (foundCard != nil) then: {
                       log("Zut ! J'ai la carte " + foundCard.type + ". Je dois la donner.");
                       def giveOp := isolate: {
                           def uuid := UUID.randomUUID().toString();
                           def type := "GIVE_CARD";
                           def fromId := myUserId;
                           def toId := op.fromId;
                           def card := foundCard;
                           def sessionId := currentSessionId;
                       };
                       performTwoPhaseCommit(giveOp);
                   } else: {
                       log("Ouf ! Je n'ai pas la carte demandée (" + op.reqType + ").");
                   };
               } else: {
                   log(op.fromId + " demande une carte précise à " + op.targetPlayer);
               };
           };
       };

       // --- 8. PLAY SPECIAL 5 (COMBO 5) ---
       if: (op.type == "PLAY_SPECIAL_5") then: {

           def status := "UNKNOWN";
           def pile := [];
           try: {
               if: (res.length == 2) then: {
                   status := res[1];
                   pile := res[2];
               };
           } catch: { |e| };

           // [FIX VISUEL COMPLET] TOUT LE MONDE met à jour sa pile (même celui qui joue)
           if: ((status == "COMBO_5_OK").and: { pile.length >= 5 }) then: {
               def len := pile.length;
               (len - 4).to: len do: { |i|
                   def c := pile[i];
                   gui.playCardOpponent(c.type, c.variant);
               };
           };

           if: (op.fromId == myUserId) then: {
               updateJavaHand(myUserId);
               if: (status == "COMBO_5_OK") then: {
                   def typesList := jlobby.java.util.ArrayList.new();
                   def varsList := jlobby.java.util.ArrayList.new();
                   pile.each: { |c| typesList.add(c.type); varsList.add(c.variant); };
                   gui.askPickFromDiscard(typesList, varsList);
               };
           } else: {
               localInterface.showMessage(op.fromId + " joue le COMBO 5 CARTES !");
           };
       };

       // --- 9. TAKE DISCARD ---
       if: (op.type == "TAKE_DISCARD") then: {
           localInterface.showMessage(op.fromId + " a récupéré une carte de la défausse.");
           if: (op.fromId == myUserId) then: {
               updateJavaHand(myUserId);
           };
       };

       updateTurnDisplay();
   };

   // --- UTILS ---
        def getRelativeIndex(targetId) {
             def myIndex := -1;
             def targetIndex := -1;
             def count := sessionPlayerIds.length;
             def i := 0;

             sessionPlayerIds.each: { |pid|
                 if: (pid == myUserId) then: { myIndex := i; };
                 if: (pid == targetId) then: { targetIndex := i; };
                 i := i + 1;
             };

             def relative := (targetIndex - myIndex + count) % count;
             if: (count == 2) then: {
                 if: (relative == 1) then: { relative := 2; };
             };

             relative;
        };

     def markDeadOpponent(deadId) {
          def myIndex := -1;
          def oppIndex := -1;
          def count := sessionPlayerIds.length;

          def i := 0;
          sessionPlayerIds.each: { |pid|
              if: (pid == myUserId) then: { myIndex := i; };
              if: (pid == deadId) then: { oppIndex := i; };
              i := i + 1;
          };

          def relative := (oppIndex - myIndex + count) % count;
          if: (count == 2) then: {
              if: (relative == 1) then: { relative := 2; };
          };

          system.println("[GUI] Marking DEAD oppId: " + deadId + " at relative pos: " + relative);
          gui.markOpponentDead(relative);
     };

  def remoteInterface := object: {
    def getUserId() { myUserId; };

    def updatePlayerState(id, state) {
        log("UPDATE: Player " + id + " state -> " + state);
        playerStates.put(id, state);
        checkLobbyStatus();
    };

    def inviteToSession(sessionId, initiatorId, config, pList) {
        if: (myState == LOBBY) then: {
            myState := PLAYING;
            currentSessionId := sessionId;
            sessionPlayerIds := pList;

            gameModel := makeGameRules(sessionPlayerIds);
            gameModel.initGame(config);

            updateJavaHand(myUserId);
            gui.initializeSession(sessionPlayerIds.length);
            updateTurnDisplay();

            broadcastMyState(myState);
            log("INVITATION ACCEPTED from " + initiatorId);
            localInterface.showMessage("Joined session.");
        } else: {
            log("INVITATION DECLINED: Busy.");
        };
    };

    def prepare(op) { gameModel.validateMove(op); };
    def commit(op) { commitLocally(op); };
  };

  def pub := nil;
  def sub := nil;

  def goOnline() {
    pub := export: remoteInterface as: Player;

    sub := whenever: Player discovered: { |player|
         when: player<-getUserId()@FutureMessage becomes: { |id|
             if: (!(playersById.containsKey(id))) then: {
                 if: (id != myUserId) then: {
                     log("New player: " + id);
                     playersById.put(id, player);

                     if: (!playerStates.containsKey(id)) then: {
                        playerStates.put(id, LOBBY);
                     };

                     playerIdsList := playerIdsList + [id];
                     player<-updatePlayerState(myUserId, myState);
                     checkLobbyStatus();

                     whenever: player disconnected: {
                         log("Player " + id + " left.");
                         playersById.remove(id);
                         playerStates.remove(id);
                         playerIdsList := playerIdsList.filter: { |itemId| itemId != id };
                         if: ((myState == PLAYING).and: { sessionPlayerIds.contains(id) }) then: {
                             log("Active player disconnected. Removing...");
                             def op := isolate: {
                                 def type := "PLAYER_LEFT";
                                 def fromId := id;
                             };
                             commitLocally(op);
                             localInterface.showMessage("Player " + id + " disconnected.");
                         };
                     };
                 };
             };
         };
    };
  };

  def goOffline(){
    pub.cancel();
    sub.cancel();
  };

  gui := WeKittensApp.new(localInterface);
  goOnline();
  system.println("WeKittens ready. GUI: " + gui);
};

network.online();
makeAmbientKittens();