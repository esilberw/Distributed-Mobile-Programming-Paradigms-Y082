def ArrayList := jlobby.java.util.ArrayList;
def Deck := jlobby.weKittens.Deck;
def CardType := jlobby.weKittens.Card.CardType;

object: {
  // --- IMPORTS ISOLES ---
  def Data := object: { import ~.data; };
  def Collections := object: { import /.at.collections.java.hashmap; };

  def makeGameRules(playerIds) {
    def deck := [];
    def hands := Collections.HashMap.new();
    def activePlayers := playerIds;
    def currentPlayerIndex := 0;

    // --- GESTION DES TOURS ---
    def turnsToTake := 1;
    def nextTurnCount := 1;

    def deadPlayers := [];
    def discardPile := [];

    // On garde l'accès à Data pour l'initialisation et la recovery
    def localAtCard := Data.atCard;

    isolate: {
        def createInitialState() {
            system.println("[RULES] Generation via Deck.java...");

            def jDeck := Deck.new(activePlayers.length);
            def initialHands := Collections.HashMap.new();

            // 1. DISTRIBUTION COMPLETE (1 Defuse + 7 Cartes)
            // On fait tout en une seule passe pour éviter les bugs de Map
            activePlayers.each: { |pid|
                def hand := [];

                // A. On donne le Defuse garanti
                def jDefuse := jDeck.takeCard(CardType.defuse);
                if: (jDefuse != nil) then: {
                    hand := hand + [Data.atCardFromJCard(jDefuse)];
                } else: {
                    system.println("[ERROR] Plus de Defuse disponible pour " + pid);
                };

                // B. On donne 7 cartes au hasard
                1.to: 8 do: { |i|
                    def jCard := jDeck.drawCard();
                    if: !(jCard == nil) then: {
                        hand := hand + [Data.atCardFromJCard(jCard)];
                    };
                };

                initialHands.put(pid, hand);
                system.println("[RULES] Main distribuée à " + pid + " (" + hand.length + " cartes)");
            };

            // 2. EXPLODING KITTENS
            // On ajoute les bombes APRES avoir distribué les mains (pour ne pas en piocher au départ)
            jDeck.addExplodingKittens();

            // 3. RECUPERATION DU DECK FINAL
            def finalDeck := [];
            def pulling := true;
            while: { pulling } do: {
                def c := jDeck.drawCard();
                if: (c == nil) then: { pulling := false; } else: {
                    finalDeck := finalDeck + [Data.atCardFromJCard(c)];
                };
            };

            system.println("[RULES] Deck Final Prêt (" + finalDeck.length + " cartes).");

            def serializableHands := [];
            activePlayers.each: { |pid|
                def h := initialHands.get(pid);
                serializableHands := serializableHands + [[pid, h]];
            };

            isolate: {
                def syncedDeck := finalDeck;
                def syncedHandsData := serializableHands;
            };
        };

        def initGame(config) {
            deck := config.syncedDeck;
            hands := Collections.HashMap.new();
            def listData := config.syncedHandsData;

            listData.each: { |entry|
                def pid := entry[1];
                def hand := entry[2];
                hands.put(pid, hand);
            };

            activePlayers := playerIds;
            discardPile := [];
            currentPlayerIndex := 0;
            turnsToTake := 1;
            nextTurnCount := 1;
            deadPlayers := [];
            system.println("[RULES] GAME INIT COMPLETE. Deck Size: " + deck.length);
        };

        // --- ACCESSEURS ---
        def getCurrentPlayer() {
            def p := nil;
            if: !(activePlayers.isEmpty()) then: { p := activePlayers[currentPlayerIndex + 1]; };
            p;
        };

        def getTurnsLeft() { turnsToTake; };
        def getDeckSize() { deck.length; };
        def getHand(pid) { hands.get(pid); };

        def validateMove(op) {
            def pid := op.fromId;
            def isValid := true;

            if: (deadPlayers.contains(pid)) then: {
                isValid := false;
            } else: {
                if: (op.type == "PLAY_CARD") then: {
                     if: !(op.card.type == "nope") then: {
                         if: !(pid == getCurrentPlayer()) then: {
                             isValid := false;
                         };
                     };
                };
                if: (op.type == "DRAW_CARD") then: {
                    if: !(pid == getCurrentPlayer()) then: { isValid := false; };
                };
                if: (op.type == "PLAY_CARD") then: {
                   if: (isValid) then: {
                       def h := getHand(pid);
                       def has := false;
                       h.each: { |c| if: (c.type == op.card.type) then: { has := true; }; };
                       if: !has then: { isValid := false; };
                   };
                };
                if: (op.type == "PLAY_PAIR") then: {
                                   if: (isValid) then: {
                                       def h := getHand(pid);
                                       def count := 0;

                                       // On doit avoir au moins 2 cartes de ce type/variant
                                       h.each: { |c|
                                           // CORRECTION : Imbrication des IF pour éviter le bug "and:then:"
                                           if: (c.type == op.card.type) then: {
                                               if: (c.variant == op.card.variant) then: {
                                                   count := count + 1;
                                               };
                                           };
                                       };

                                       if: (count < 2) then: { isValid := false; };
                                   };
                                };
                                // VALIDATION TRIPLE
                                                if: (op.type == "PLAY_TRIPLE") then: {
                                                   if: (isValid) then: {
                                                       def h := getHand(pid);
                                                       def count := 0;
                                                       h.each: { |c|
                                                           if: (c.type == op.card.type) then: {
                                                               if: (c.variant == op.card.variant) then: {
                                                                   count := count + 1;
                                                               };
                                                           };
                                                       };
                                                       // Il faut 3 cartes identiques
                                                       if: (count < 3) then: { isValid := false; };
                                                   };
                                                };
                               // --- AJOUT : VALIDATION 5 CARTES DIFFERENTES ---
                                               if: (op.type == "PLAY_SPECIAL_5") then: {
                                                   if: (isValid) then: {
                                                       def h := getHand(pid);
                                                       def uniqueKeys := [];

                                                       // On compte les cartes uniques (Type + Variante pour les Chats)
                                                       h.each: { |c|
                                                           def key := c.type;
                                                           // ASTUCE : Si c'est un chat, on ajoute la variante à la clé pour les différencier
                                                           if: (c.type == "cat") then: { key := c.type + c.variant; };

                                                           if: !(uniqueKeys.contains(key)) then: {
                                                               uniqueKeys := uniqueKeys + [key];
                                                           };
                                                       };

                                                       if: (uniqueKeys.length < 5) then: { isValid := false; };
                                                   };
                                               };

                                                // --- AJOUT : VALIDATION RECUPERATION DEFAUSSE ---
                                                if: (op.type == "TAKE_DISCARD") then: {
                                                    if: (isValid) then: {
                                                        // On vérifie que la carte demandée est bien dans la défausse
                                                        def found := false;
                                                        discardPile.each: { |c|
                                                            if: ((c.type == op.card.type).and: {c.variant == op.card.variant}) then: {
                                                                found := true;
                                                            };
                                                        };
                                                        if: !found then: { isValid := false; };
                                                    };
                                                };
                            };
                            isValid;
                        };

        def applyMove(op) {
                    def type := op.type;
                    def pid := op.fromId;
                    def result := "OK";

                    // --- 1. PLAY CARD (Classique) ---
                    if: (type == "PLAY_CARD") then: {
                        def card := op.card;
                        system.println("[JEU] " + pid + " joue " + card.type);

                        removeCardFromHand(pid, card);
                        discardPile := discardPile + [card];

                        // --- ATTACK ---
                        if: (card.type == "attack") then: {
                            def remaining := turnsToTake - 1;
                            if: (remaining < 0) then: { remaining := 0; };
                            nextTurnCount := remaining + 2;
                            system.println("[ATTACK] Stacking! Next player will have " + nextTurnCount + " turns.");
                            passTurnNoDraw();
                        };

                        // --- SKIP ---
                        if: (card.type == "skip") then: {
                            turnsToTake := turnsToTake - 1;
                            if: (turnsToTake <= 0) then: { passTurnNoDraw(); };
                        };

                        // --- SHUFFLE ---
                        if: (card.type == "shuffle") then: {
                             def seeds := op.shuffleData;
                             def len := deck.length;
                             if: ((len > 1).and: { seeds.length > 0 }) then: {
                                def i := 1;
                                while: { i < (seeds.length - 1) } do: {
                                    def randA := seeds[i];
                                    def randB := seeds[i+1];
                                    def idxA := (randA * len).round() + 1;
                                    def idxB := (randB * len).round() + 1;
                                    if: (idxA > len) then: { idxA := len; };
                                    if: (idxB > len) then: { idxB := len; };
                                    if: (idxA < 1) then: { idxA := 1; };
                                    if: (idxB < 1) then: { idxB := 1; };
                                    def temp := deck[idxA];
                                    deck[idxA] := deck[idxB];
                                    deck[idxB] := temp;
                                    i := i + 2;
                                };
                            };
                        };

                        // --- SEE THE FUTURE ---
                        if: (card.type == "future") then: {
                            def peekCards := [];
                            def count := 0;
                            def idx := 1;
                            while: { (count < 3).and: { idx <= deck.length } } do: {
                                peekCards := peekCards + [deck[idx]];
                                idx := idx + 1;
                                count := count + 1;
                            };
                            result := ["PEEK_FUTURE", peekCards];
                        };

                    }; // <--- IMPORTANT : On ferme PLAY_CARD ici !

                    // --- 2. PLAY PAIR (Maintenant au même niveau que PLAY_CARD) ---
                    if: (type == "PLAY_PAIR") then: {
                        def card := op.card;
                        system.println("[JEU] " + pid + " joue PAIRE de " + card.type);

                        // On retire les 2 cartes [cite: 8]
                        removeCardFromHand(pid, card);
                        removeCardFromHand(pid, card);

                        discardPile := discardPile + [card, card];
                        result := "PAIR_OK";
                    };

                    // --- 3. PLAY TRIPLE (Au même niveau aussi) ---
                    if: (type == "PLAY_TRIPLE") then: {
                        def card := op.card;
                        system.println("[JEU] " + pid + " joue TRIPLE de " + card.type);

                        // On retire les 3 cartes
                        removeCardFromHand(pid, card);
                        removeCardFromHand(pid, card);
                        removeCardFromHand(pid, card);

                        discardPile := discardPile + [card, card, card];
                        result := "TRIPLE_OK";
                    };
// --- 4. PLAY SPECIAL 5 (5 Différentes) ---
            if: (type == "PLAY_SPECIAL_5") then: {
                system.println("[JEU] " + pid + " joue COMBO 5 SPECIAL");

                def hand := getHand(pid);
                def uniqueKeysFound := [];
                def cardsToRemove := [];

                // 1. Sélectionner les 5 cartes (en distinguant les Chats)
                hand.each: { |c|
                    if: (uniqueKeysFound.length < 5) then: {
                        def key := c.type;
                        if: (c.type == "cat") then: { key := c.type + c.variant; };

                        if: !(uniqueKeysFound.contains(key)) then: {
                            uniqueKeysFound := uniqueKeysFound + [key];
                            cardsToRemove := cardsToRemove + [c];
                        };
                    };
                };

                // 2. Les retirer et mettre à jour la défausse
                cardsToRemove.each: { |c|
                    removeCardFromHand(pid, c);
                    // On ajoute bien la carte à la pile
                    discardPile := discardPile + [c];
                };

                system.println("[COMBO 5] " + cardsToRemove.length + " cartes ajoutées à la défausse.");

                // 3. RENVOYER LE CONTENU DE LA DEFAUSSE (Mis à jour)
                result := ["COMBO_5_OK", discardPile];
            };
                                // --- 5. TAKE DISCARD (Récupération) ---
                                if: (type == "TAKE_DISCARD") then: {
                                    def targetCard := op.card;
                                    system.println("[JEU] " + pid + " récupère " + targetCard.type + " de la défausse");

                                    // 1. Retirer de la défausse (Une seule instance)
                                    def newDiscard := [];
                                    def found := false;
                                    discardPile.each: { |c|
                                        if: !found then: {
                                            if: ((c.type == targetCard.type).and: {c.variant == targetCard.variant}) then: {
                                                found := true; // On saute celle-ci (retrait)
                                            } else: {
                                                newDiscard := newDiscard + [c];
                                            };
                                        } else: {
                                            newDiscard := newDiscard + [c];
                                        };
                                    };
                                    discardPile := newDiscard;

                                    // 2. Ajouter à la main
                                    def h := getHand(pid);
                                    if: (h != nil) then: {
                                        hands.put(pid, h + [targetCard]);
                                    };

                                    result := "RECOVERED";
                                };

                    // --- 4. DRAW CARD ---
                    if: (type == "DRAW_CARD") then: {
                         // ... (Votre code DRAW_CARD existant, inchangé) ...
                         // Copiez-collez tout le bloc DRAW_CARD ici
                          if: (deck.isEmpty()) then: {
                            result := "EMPTY";
                        } else: {
                            def oldSize := deck.length;
                            def card := deck[1];

                            // --- DECOUPAGE DU DECK (While) ---
                            def newDeck := [];
                            def len := deck.length;
                            def idx := 2;
                            while: { idx <= len } do: {
                                newDeck := newDeck + [deck[idx]];
                                idx := idx + 1;
                            };
                            deck := newDeck;

                            system.println("[DRAW] " + pid + " drew " + card.type + ". Deck size: " + oldSize + " -> " + deck.length);
                            if: (card.type == "exploding") then: {
                                                   def hand := getHand(pid);
                                                   def hasDefuse := false;
                                                   hand.each: { |c| if: (c.type == "defuse") then: { hasDefuse := true; }; };
                                                   if: (hasDefuse) then: {
                                                       hands.put(pid, hands.get(pid) + [card]);
                                                       // On renvoie [STATUS, CARD] pour avoir l'info visuelle
                                                       result := ["MUST_DEFUSE", card];
                                                   } else: {
                                                       killPlayer(pid);
                                                       // MEME EN MOURANT, on renvoie la carte pour l'afficher
                                                       if: (activePlayers.length == 1) then: {
                                                            result := ["WINNER", card];
                                                       } else: {
                                                           result := ["DIED", card];
                                                       };
                                                   };
                            } else: {
                                hands.put(pid, hands.get(pid) + [card]);
                                turnsToTake := turnsToTake - 1;
                                if: (turnsToTake <= 0) then: { advanceTurn(); };
                                result := card;
                            };
                        };
                    };

                    // ... (Autres blocs DEFUSE, GIVE_CARD, PLAYER_LEFT restent inchangés) ...
                     if: (type == "DEFUSE_KITTEN") then: {
                         // ... (votre code DEFUSE existant) ...
                          system.println("[DEFUSE] Start. Deck size: " + deck.length);
                         def hand := getHand(pid);
                         def defuseCard := nil;
                         def kittenCard := nil;

                         hand.each: { |c|
                             if: ((defuseCard == nil).and: { c.type == "defuse" }) then: { defuseCard := c; };
                             if: ((kittenCard == nil).and: { c.type == "exploding" }) then: { kittenCard := c; };
                         };
                         if: (defuseCard != nil) then: {
                            removeCardFromHand(pid, defuseCard);
                            discardPile := discardPile + [defuseCard];
                         };

                         if: (kittenCard != nil) then: {
                            removeCardFromHand(pid, kittenCard);
                             def idx := op.insertIndex;
                             def insertDeck := [];
                             def inserted := false;
                             def i := 0;
                             if: (idx == 0) then: { insertDeck := insertDeck + [kittenCard]; inserted := true; };

                             deck.each: { |c|
                                 insertDeck := insertDeck + [c];
                                 i := i + 1;
                                 if: ((i == idx).and: { !inserted }) then: {
                                    insertDeck := insertDeck + [kittenCard];
                                    inserted := true;
                                 };
                             };
                             if: !inserted then: { insertDeck := insertDeck + [kittenCard]; };

                             deck := insertDeck;
                             system.println("[DEFUSE] SUCCESS. Kitten re-inserted at " + idx + ". New Deck size: " + deck.length);
                         } else: {
                             system.println("[CRITICAL ERROR] No kitten found in hand! Creating backup.");
                             def backupBomb := localAtCard.new("exploding", "a");
                             deck := deck + [backupBomb];
                         };

                         turnsToTake := turnsToTake - 1;
                         if: (turnsToTake <= 0) then: { advanceTurn(); };
                         result := "DEFUSED";
                     };

                     // --- GIVE CARD (Pour Favor / Vol) ---
                                 if: (type == "GIVE_CARD") then:{
                                     def card := op.card;
                                     def targetId := op.toId; // Celui qui reçoit (l'attaquant)

                                     system.println("[GIVE] " + pid + " donne " + card.type + " à " + targetId);

                                     // 1. Retirer de la main du donneur (la victime, pid)
                                     removeCardFromHand(pid, card);

                                     // 2. Ajouter à la main du receveur (l'attaquant, targetId)
                                     def targetHand := getHand(targetId);
                                     if: (targetHand != nil) then: {
                                         targetHand := targetHand + [card];
                                         hands.put(targetId, targetHand);
                                     };

                                     result := "GIVEN";
                                 };

                     if: (type == "PLAYER_LEFT") then: {
                          // ... (votre code LEFT existant) ...
                           killPlayer(pid);
                        def hand := getHand(pid);

                        if: (activePlayers.length == 1) then: {
                            result := "WINNER";
                        } else: {
                            result := "DIED";
                        };
                     };

                    result;
                };

        def removeCardFromHand(pid, cardTemplate) {
                    def hand := getHand(pid);
                    def newHand := [];
                    def removed := false;

                    if: (hand != nil) then: {
                        hand.each: { |card|
                            // Par défaut, on garde la carte
                            def keepCard := true;

                            // Si on n'a pas encore retiré la carte cible...
                            if: !removed then: {
                                // ... et que le Type correspond
                                if: (card.type == cardTemplate.type) then: {
                                    // ... et que la Variante correspond
                                    if: (card.variant == cardTemplate.variant) then: {
                                        // ALORS c'est la carte à supprimer
                                        removed := true;
                                        keepCard := false;
                                    };
                                };
                            };

                            // Si on doit garder la carte, on l'ajoute à la nouvelle main
                            if: keepCard then: {
                                newHand := newHand + [card];
                            };
                        };
                        hands.put(pid, newHand);
                    };
                };

        def passTurnNoDraw() {
            system.println("[PASS] Turn Pass (skip)");
            advanceTurn();
        };

        def advanceTurn() {
            currentPlayerIndex := (currentPlayerIndex + 1) % activePlayers.length;
            turnsToTake := nextTurnCount;
            nextTurnCount := 1;
            system.println("[TURN] Player " + getCurrentPlayer() + " (actions: " + turnsToTake + ")");
        };

        // Ajoutez ceci dans la section ACCESSEURS (vers la ligne 737)
                def getDiscardTop() {
                    def c := nil;
                    if: !(discardPile.isEmpty()) then: {
                        c := discardPile[discardPile.length];
                    };
                    c;
                };

        // Remplacez la fonction killPlayer par celle-ci (vers la ligne 833)
                def killPlayer(pid) {
                    def idxToRemove := -1;
                    def i := 0;
                    activePlayers.each: { |p| if: (p == pid) then: { idxToRemove := i; }; i := i + 1; };

                    if: (idxToRemove > -1) then: {
                        // 1. Transfert de la main vers la défausse
                        def hand := hands.get(pid);
                        if: (hand != nil) then: {
                            system.println("[RULES] Transfert main de " + pid + " vers défausse (" + hand.length + " cartes).");
                            discardPile := discardPile + hand;
                            hands.remove(pid);
                        };

                        // 2. Exclusion du joueur
                        def newActive := [];
                        activePlayers.each: { |p| if: (p != pid) then: { newActive := newActive + [p]; }; };
                        activePlayers := newActive;
                        deadPlayers := deadPlayers + [pid];

                        // 3. Ajustement du tour
                        if: (idxToRemove < currentPlayerIndex) then: { currentPlayerIndex := currentPlayerIndex - 1; };
                        if: (currentPlayerIndex >= activePlayers.length) then: { currentPlayerIndex := 0; };

                        turnsToTake := 1;
                        nextTurnCount := 1;
                        system.println("[DEAD] Player " + pid + " is DEAD.");
                    };
                };
    };
  };
};