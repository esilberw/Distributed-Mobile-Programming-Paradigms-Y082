def ArrayList := jlobby.java.util.ArrayList;
def Deck := jlobby.weKittens.Deck;
def CardType := jlobby.weKittens.Card.CardType;

object: {
  // --- IMPORTS ISOLES ---
  def Data := object: { import ~.data; };
  def Collections := object: { import /.at.collections.java.hashmap; };

  def makeGameRules(playerIds) {
    def deck := [];
    def hands := Collections.HashMap.new();
    def activePlayers := playerIds;
    def currentPlayerIndex := 0;

    // --- GESTION DES TOURS ---
    def turnsToTake := 1;
    def nextTurnCount := 1;

    def deadPlayers := [];
    def discardPile := [];

    // On garde l'accès à Data pour l'initialisation et la recovery
    def localAtCard := Data.atCard;

    isolate: {
        def createInitialState() {
            system.println("[RULES] Generation via Deck.java...");

            def jDeck := Deck.new(activePlayers.length);
            def initialHands := Collections.HashMap.new();

            // 1. DISTRIBUTION COMPLETE (1 Defuse + 7 Cartes)
            // On fait tout en une seule passe pour éviter les bugs de Map
            activePlayers.each: { |pid|
                def hand := [];

                // A. On donne le Defuse garanti
                def jDefuse := jDeck.takeCard(CardType.defuse);
                if: (jDefuse != nil) then: {
                    hand := hand + [Data.atCardFromJCard(jDefuse)];
                } else: {
                    system.println("[ERROR] Plus de Defuse disponible pour " + pid);
                };

                // B. On donne 7 cartes au hasard
                1.to: 8 do: { |i|
                    def jCard := jDeck.drawCard();
                    if: !(jCard == nil) then: {
                        hand := hand + [Data.atCardFromJCard(jCard)];
                    };
                };

                initialHands.put(pid, hand);
                system.println("[RULES] Main distribuée à " + pid + " (" + hand.length + " cartes)");
            };

            // 2. EXPLODING KITTENS
            // On ajoute les bombes APRES avoir distribué les mains (pour ne pas en piocher au départ)
            jDeck.addExplodingKittens();

            // 3. RECUPERATION DU DECK FINAL
            def finalDeck := [];
            def pulling := true;
            while: { pulling } do: {
                def c := jDeck.drawCard();
                if: (c == nil) then: { pulling := false; } else: {
                    finalDeck := finalDeck + [Data.atCardFromJCard(c)];
                };
            };

            system.println("[RULES] Deck Final Prêt (" + finalDeck.length + " cartes).");

            def serializableHands := [];
            activePlayers.each: { |pid|
                def h := initialHands.get(pid);
                serializableHands := serializableHands + [[pid, h]];
            };

            isolate: {
                def syncedDeck := finalDeck;
                def syncedHandsData := serializableHands;
            };
        };

        def initGame(config) {
            deck := config.syncedDeck;
            hands := Collections.HashMap.new();
            def listData := config.syncedHandsData;

            listData.each: { |entry|
                def pid := entry[1];
                def hand := entry[2];
                hands.put(pid, hand);
            };

            activePlayers := playerIds;
            discardPile := [];
            currentPlayerIndex := 0;
            turnsToTake := 1;
            nextTurnCount := 1;
            deadPlayers := [];
            system.println("[RULES] GAME INIT COMPLETE. Deck Size: " + deck.length);
        };

        // --- ACCESSEURS ---
        def getCurrentPlayer() {
            def p := nil;
            if: !(activePlayers.isEmpty()) then: { p := activePlayers[currentPlayerIndex + 1]; };
            p;
        };

        def getTurnsLeft() { turnsToTake; };
        def getDeckSize() { deck.length; };
        def getHand(pid) { hands.get(pid); };

        def validateMove(op) {
            def pid := op.fromId;
            def isValid := true;

            if: (deadPlayers.contains(pid)) then: {
                isValid := false;
            } else: {
                if: (op.type == "PLAY_CARD") then: {
                     if: !(op.card.type == "nope") then: {
                         if: !(pid == getCurrentPlayer()) then: {
                             isValid := false;
                         };
                     };
                };
                if: (op.type == "DRAW_CARD") then: {
                    if: !(pid == getCurrentPlayer()) then: { isValid := false; };
                };
                if: (op.type == "PLAY_CARD") then: {
                   if: (isValid) then: {
                       def h := getHand(pid);
                       def has := false;
                       h.each: { |c| if: (c.type == op.card.type) then: { has := true; }; };
                       if: !has then: { isValid := false; };
                   };
                };
            };
            isValid;
        };

        def applyMove(op) {
            def type := op.type;
            def pid := op.fromId;
            def result := "OK";


            // --- PLAY CARD ---
                        if: (type == "PLAY_CARD") then: {
                            def card := op.card;
                            system.println("[JEU] " + pid + " joue " + card.type);

                            removeCardFromHand(pid, card);
                            discardPile := discardPile + [card];

                            // --- ATTACK ---
                            if: (card.type == "attack") then: {
                                def remaining := turnsToTake - 1;
                                if: (remaining < 0) then: { remaining := 0; };
                                nextTurnCount := remaining + 2;
                                system.println("[ATTACK] Stacking! Next player will have " + nextTurnCount + " turns.");
                                passTurnNoDraw();
                            };

                            // --- SKIP ---
                            if: (card.type == "skip") then: {
                                turnsToTake := turnsToTake - 1;
                                if: (turnsToTake <= 0) then: { passTurnNoDraw(); };
                            };

                            // --- SHUFFLE ---
                            if: (card.type == "shuffle") then: {
                                // ... (votre code shuffle existant) ...
                                // (Laissez le bloc shuffle tel quel)
                                 def seeds := op.shuffleData;
                                def len := deck.length;
                                if: ((len > 1).and: { seeds.length > 0 }) then: {
                                    def i := 1;
                                    while: { i < (seeds.length - 1) } do: {
                                        def randA := seeds[i];
                                        def randB := seeds[i+1];
                                        def idxA := (randA * len).round() + 1;
                                        def idxB := (randB * len).round() + 1;
                                        if: (idxA > len) then: { idxA := len; };
                                        if: (idxB > len) then: { idxB := len; };
                                        if: (idxA < 1) then: { idxA := 1; };
                                        if: (idxB < 1) then: { idxB := 1; };
                                        def temp := deck[idxA];
                                        deck[idxA] := deck[idxB];
                                        deck[idxB] := temp;
                                        i := i + 2;
                                    };
                                };
                            };

                            // --- SEE THE FUTURE (AJOUT) ---
                            if: (card.type == "future") then: {
                                def peekCards := [];
                                def count := 0;
                                def idx := 1; // Deck commence à 1

                                // On regarde jusqu'à 3 cartes, ou moins si le deck est petit
                                while: { (count < 3).and: { idx <= deck.length } } do: {
                                    peekCards := peekCards + [deck[idx]];
                                    idx := idx + 1;
                                    count := count + 1;
                                };

                                // On renvoie un résultat spécial contenant les cartes
                                result := ["PEEK_FUTURE", peekCards];
                            };
                        };

            // --- DRAW CARD ---
            if: (type == "DRAW_CARD") then: {
                if: (deck.isEmpty()) then: {
                    result := "EMPTY";
                } else: {
                    def oldSize := deck.length;
                    def card := deck[1];

                    // --- DECOUPAGE DU DECK (While) ---
                    def newDeck := [];
                    def len := deck.length;
                    def idx := 2;
                    while: { idx <= len } do: {
                        newDeck := newDeck + [deck[idx]];
                        idx := idx + 1;
                    };
                    deck := newDeck;

                    system.println("[DRAW] " + pid + " drew " + card.type + ". Deck size: " + oldSize + " -> " + deck.length);

                   if: (card.type == "exploding") then: {
                                           def hand := getHand(pid);
                                           def hasDefuse := false;
                                           hand.each: { |c| if: (c.type == "defuse") then: { hasDefuse := true; }; };

                                           if: (hasDefuse) then: {
                                               hands.put(pid, hands.get(pid) + [card]);
                                               // On renvoie [STATUS, CARD] pour avoir l'info visuelle
                                               result := ["MUST_DEFUSE", card];
                                           } else: {
                                               killPlayer(pid);
                                               // MEME EN MOURANT, on renvoie la carte pour l'afficher
                                               if: (activePlayers.length == 1) then: {
                                                   result := ["WINNER", card];
                                               } else: {
                                                   result := ["DIED", card];
                                               };
                                           };
                    } else: {
                        hands.put(pid, hands.get(pid) + [card]);
                        turnsToTake := turnsToTake - 1;
                        if: (turnsToTake <= 0) then: { advanceTurn(); };
                        result := card;
                    };
                };
            };

            // --- DEFUSE ---
            if: (type == "DEFUSE_KITTEN") then: {
                 system.println("[DEFUSE] Start. Deck size: " + deck.length);

                 def hand := getHand(pid);
                 def defuseCard := nil;
                 def kittenCard := nil;

                 hand.each: { |c|
                    if: ((defuseCard == nil).and: { c.type == "defuse" }) then: { defuseCard := c; };
                    if: ((kittenCard == nil).and: { c.type == "exploding" }) then: { kittenCard := c; };
                 };

                 if: (defuseCard != nil) then: {
                    removeCardFromHand(pid, defuseCard);
                    discardPile := discardPile + [defuseCard];
                 };

                 if: (kittenCard != nil) then: {
                    removeCardFromHand(pid, kittenCard);

                     def idx := op.insertIndex;
                     def insertDeck := [];
                     def inserted := false;
                     def i := 0;

                     if: (idx == 0) then: { insertDeck := insertDeck + [kittenCard]; inserted := true; };

                     deck.each: { |c|
                         insertDeck := insertDeck + [c];
                         i := i + 1;
                         if: ((i == idx).and: { !inserted }) then: {
                            insertDeck := insertDeck + [kittenCard];
                            inserted := true;
                         };
                     };
                     if: !inserted then: { insertDeck := insertDeck + [kittenCard]; };

                     deck := insertDeck;
                     system.println("[DEFUSE] SUCCESS. Kitten re-inserted at " + idx + ". New Deck size: " + deck.length);
                 } else: {
                     system.println("[CRITICAL ERROR] No kitten found in hand! Creating backup.");
                     def backupBomb := localAtCard.new("exploding", "a");
                     deck := deck + [backupBomb];
                 };

                 turnsToTake := turnsToTake - 1;
                 if: (turnsToTake <= 0) then: { advanceTurn(); };
                 result := "DEFUSED";
            };
            // >>> INSÉREZ LE BLOC ICI <<<
                        // --- GIVE CARD (Pour Favor) ---
                        if: (type == "GIVE_CARD") then: {
                            def card := op.card;
                            def targetId := op.toId; // Celui qui reçoit

                            system.println("[GIVE] " + pid + " donne " + card.type + " à " + targetId);

                            // 1. Retirer de la main du donneur (pid)
                            removeCardFromHand(pid, card);

                            // 2. Ajouter à la main du receveur (targetId)
                            def targetHand := getHand(targetId);
                            if: (targetHand != nil) then: {
                                targetHand := targetHand + [card];
                                hands.put(targetId, targetHand);
                            };

                            result := "GIVEN";
                        };
                        // >>> FIN DU BLOC <<<


            if: (type == "PLAYER_LEFT") then: {
                killPlayer(pid);
                def hand := getHand(pid);
                if: !(hand == nil) then: { discardPile := discardPile + hand; hands.remove(pid); };

                if: (activePlayers.length == 1) then: {
                    result := "WINNER";
                } else: {
                    result := "DIED";
                };
            };
            result;
        };

        def removeCardFromHand(pid, cardTemplate) {
                    def hand := getHand(pid);
                    def newHand := [];
                    def removed := false;

                    if: (hand != nil) then: {
                        hand.each: { |card|
                            // Par défaut, on garde la carte
                            def keepCard := true;

                            // Si on n'a pas encore retiré la carte cible...
                            if: !removed then: {
                                // ... et que le Type correspond
                                if: (card.type == cardTemplate.type) then: {
                                    // ... et que la Variante correspond
                                    if: (card.variant == cardTemplate.variant) then: {
                                        // ALORS c'est la carte à supprimer
                                        removed := true;
                                        keepCard := false;
                                    };
                                };
                            };

                            // Si on doit garder la carte, on l'ajoute à la nouvelle main
                            if: keepCard then: {
                                newHand := newHand + [card];
                            };
                        };
                        hands.put(pid, newHand);
                    };
                };

        def passTurnNoDraw() {
            system.println("[PASS] Turn Pass (skip)");
            advanceTurn();
        };

        def advanceTurn() {
            currentPlayerIndex := (currentPlayerIndex + 1) % activePlayers.length;
            turnsToTake := nextTurnCount;
            nextTurnCount := 1;
            system.println("[TURN] Player " + getCurrentPlayer() + " (actions: " + turnsToTake + ")");
        };

        def killPlayer(pid) {
            def idxToRemove := -1;
            def i := 0;
            activePlayers.each: { |p| if: (p == pid) then: { idxToRemove := i; }; i := i + 1; };

            if: (idxToRemove > -1) then: {
                def newActive := [];
                activePlayers.each: { |p| if: (p != pid) then: { newActive := newActive + [p]; }; };
                activePlayers := newActive;

                deadPlayers := deadPlayers + [pid];

                if: (idxToRemove < currentPlayerIndex) then: { currentPlayerIndex := currentPlayerIndex - 1; };
                if: (currentPlayerIndex >= activePlayers.length) then: { currentPlayerIndex := 0; };

                turnsToTake := 1;
                nextTurnCount := 1;
                system.println("[DEAD] Player " + pid + " is DEAD.");
            };
        };
    };
  };
};