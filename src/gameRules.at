def ArrayList := jlobby.java.util.ArrayList;
def Deck := jlobby.weKittens.Deck;
def CardType := jlobby.weKittens.Card.CardType;

object: {
  // --- IMPORTS ISOLES ---
  def Data := object: { import ~.data; };
  def Collections := object: { import /.at.collections.java.hashmap; };

  def makeGameRules(playerIds) {
    def deck := [];
    def hands := Collections.HashMap.new();
    def activePlayers := playerIds;
    def currentPlayerIndex := 0;

    // --- GESTION DES TOURS ---
    def turnsToTake := 1;
    def nextTurnCount := 1;

    def deadPlayers := [];
    def discardPile := [];

    // On garde l'accès à Data pour l'initialisation et la recovery
    def localAtCard := Data.atCard;

    isolate: {
        def createInitialState() {
            system.println("[RULES] Generation via Deck.java...");

            def jDeck := Deck.new(activePlayers.length);
            def initialHands := Collections.HashMap.new();

            // 1. DISTRIBUTION COMPLETE (1 Defuse + 7 Cartes)
            // On fait tout en une seule passe pour éviter les bugs de Map
            activePlayers.each: { |pid|
                def hand := [];

                // A. On donne le Defuse garanti
                def jDefuse := jDeck.takeCard(CardType.defuse);
                if: (jDefuse != nil) then: {
                    hand := hand + [Data.atCardFromJCard(jDefuse)];
                } else: {
                    system.println("[ERROR] Plus de Defuse disponible pour " + pid);
                };

                // B. On donne 7 cartes au hasard
                1.to: 8 do: { |i|
                    def jCard := jDeck.drawCard();
                    if: !(jCard == nil) then: {
                        hand := hand + [Data.atCardFromJCard(jCard)];
                    };
                };

                initialHands.put(pid, hand);
                system.println("[RULES] Main distribuée à " + pid + " (" + hand.length + " cartes)");
            };

            // 2. EXPLODING KITTENS
            // On ajoute les bombes APRES avoir distribué les mains (pour ne pas en piocher au départ)
            jDeck.addExplodingKittens();

            // 3. RECUPERATION DU DECK FINAL
            def finalDeck := [];
            def pulling := true;
            while: { pulling } do: {
                def c := jDeck.drawCard();
                if: (c == nil) then: { pulling := false; } else: {
                    finalDeck := finalDeck + [Data.atCardFromJCard(c)];
                };
            };

            system.println("[RULES] Deck Final Prêt (" + finalDeck.length + " cartes).");

            def serializableHands := [];
            activePlayers.each: { |pid|
                def h := initialHands.get(pid);
                serializableHands := serializableHands + [[pid, h]];
            };

            isolate: {
                def syncedDeck := finalDeck;
                def syncedHandsData := serializableHands;
            };
        };

        def initGame(config) {
            deck := config.syncedDeck;
            hands := Collections.HashMap.new();
            def listData := config.syncedHandsData;

            listData.each: { |entry|
                def pid := entry[1];
                def hand := entry[2];
                hands.put(pid, hand);
            };

            activePlayers := playerIds;
            discardPile := [];
            currentPlayerIndex := 0;
            turnsToTake := 1;
            nextTurnCount := 1;
            deadPlayers := [];
            system.println("[RULES] GAME INIT COMPLETE. Deck Size: " + deck.length);
        };

        // --- ACCESSEURS ---
        def getCurrentPlayer() {
            def p := nil;
            if: !(activePlayers.isEmpty()) then: { p := activePlayers[currentPlayerIndex + 1]; };
            p;
        };

        def getTurnsLeft() { turnsToTake; };
        def getDeckSize() { deck.length; };
        def getHand(pid) { hands.get(pid); };

        def validateMove(op) {
            def pid := op.fromId;
            def isValid := true;

            if: (deadPlayers.contains(pid)) then: {
                isValid := false;
            } else: {
                if: (op.type == "PLAY_CARD") then: {
                     if: !(op.card.type == "nope") then: {
                         if: !(pid == getCurrentPlayer()) then: {
                             isValid := false;
                         };
                     };
                };
                if: (op.type == "DRAW_CARD") then: {
                    if: !(pid == getCurrentPlayer()) then: { isValid := false; };
                };
                if: (op.type == "PLAY_CARD") then: {
                   if: (isValid) then: {
                       def h := getHand(pid);
                       def has := false;
                       h.each: { |c| if: (c.type == op.card.type) then: { has := true; }; };
                       if: !has then: { isValid := false; };
                   };
                };
            };
            isValid;
        };

        def applyMove(op) {
            def type := op.type;
            def pid := op.fromId;
            def result := "OK";

            // --- PLAY CARD ---
            if: (type == "PLAY_CARD") then: {
                def card := op.card;
                system.println("[JEU] " + pid + " joue " + card.type);

                removeCardFromHand(pid, card);
                discardPile := discardPile + [card];

                if: (card.type == "attack") then: {
                                    // CORRECTION ATTACK STACKING
                                    // Si le joueur avait des tours restants (ex: il se faisait attaquer),
                                    // il les passe au suivant + 2 nouveaux tours.
                                    // On retire 1 car le tour actuel est consommé par l'action de jouer la carte.
                                    def remaining := turnsToTake - 1;
                                    if: (remaining < 0) then: { remaining := 0; };

                                    nextTurnCount := remaining + 2;

                                    system.println("[ATTACK] Stacking! Next player will have " + nextTurnCount + " turns.");
                                    passTurnNoDraw();
                                };
                if: (card.type == "skip") then: {
                    turnsToTake := turnsToTake - 1;
                    if: (turnsToTake <= 0) then: { passTurnNoDraw(); };
                };
                // --- SHUFFLE ---
                if: (card.type == "shuffle") then: {
                    def seeds := op.shuffleData;
                    def len := deck.length;
                    if: ((len > 1).and: { seeds.length > 0 }) then: {
                        def i := 1;
                        while: { i < (seeds.length - 1) } do: {
                            def randA := seeds[i];
                            def randB := seeds[i+1];
                            def idxA := (randA * len).round() + 1;
                            def idxB := (randB * len).round() + 1;
                            if: (idxA > len) then: { idxA := len; };
                            if: (idxB > len) then: { idxB := len; };
                            if: (idxA < 1) then: { idxA := 1; };
                            if: (idxB < 1) then: { idxB := 1; };
                            def temp := deck[idxA];
                            deck[idxA] := deck[idxB];
                            deck[idxB] := temp;
                            i := i + 2;
                        };
                    };
                };
            };

            // --- DRAW CARD ---
            if: (type == "DRAW_CARD") then: {
                if: (deck.isEmpty()) then: {
                    result := "EMPTY";
                } else: {
                    def oldSize := deck.length;
                    def card := deck[1];

                    // --- DECOUPAGE DU DECK (While) ---
                    def newDeck := [];
                    def len := deck.length;
                    def idx := 2;
                    while: { idx <= len } do: {
                        newDeck := newDeck + [deck[idx]];
                        idx := idx + 1;
                    };
                    deck := newDeck;

                    system.println("[DRAW] " + pid + " drew " + card.type + ". Deck size: " + oldSize + " -> " + deck.length);

                   if: (card.type == "exploding") then: {
                                           def hand := getHand(pid);
                                           def hasDefuse := false;
                                           hand.each: { |c| if: (c.type == "defuse") then: { hasDefuse := true; }; };

                                           if: (hasDefuse) then: {
                                               hands.put(pid, hands.get(pid) + [card]);
                                               // On renvoie [STATUS, CARD] pour avoir l'info visuelle
                                               result := ["MUST_DEFUSE", card];
                                           } else: {
                                               killPlayer(pid);
                                               // MEME EN MOURANT, on renvoie la carte pour l'afficher
                                               if: (activePlayers.length == 1) then: {
                                                   result := ["WINNER", card];
                                               } else: {
                                                   result := ["DIED", card];
                                               };
                                           };
                    } else: {
                        hands.put(pid, hands.get(pid) + [card]);
                        turnsToTake := turnsToTake - 1;
                        if: (turnsToTake <= 0) then: { advanceTurn(); };
                        result := card;
                    };
                };
            };

            // --- DEFUSE ---
            if: (type == "DEFUSE_KITTEN") then: {
                 system.println("[DEFUSE] Start. Deck size: " + deck.length);

                 def hand := getHand(pid);
                 def defuseCard := nil;
                 def kittenCard := nil;

                 hand.each: { |c|
                    if: ((defuseCard == nil).and: { c.type == "defuse" }) then: { defuseCard := c; };
                    if: ((kittenCard == nil).and: { c.type == "exploding" }) then: { kittenCard := c; };
                 };

                 if: (defuseCard != nil) then: {
                    removeCardFromHand(pid, defuseCard);
                    discardPile := discardPile + [defuseCard];
                 };

                 if: (kittenCard != nil) then: {
                    removeCardFromHand(pid, kittenCard);

                     def idx := op.insertIndex;
                     def insertDeck := [];
                     def inserted := false;
                     def i := 0;

                     if: (idx == 0) then: { insertDeck := insertDeck + [kittenCard]; inserted := true; };

                     deck.each: { |c|
                         insertDeck := insertDeck + [c];
                         i := i + 1;
                         if: ((i == idx).and: { !inserted }) then: {
                            insertDeck := insertDeck + [kittenCard];
                            inserted := true;
                         };
                     };
                     if: !inserted then: { insertDeck := insertDeck + [kittenCard]; };

                     deck := insertDeck;
                     system.println("[DEFUSE] SUCCESS. Kitten re-inserted at " + idx + ". New Deck size: " + deck.length);
                 } else: {
                     system.println("[CRITICAL ERROR] No kitten found in hand! Creating backup.");
                     def backupBomb := localAtCard.new("exploding", "a");
                     deck := deck + [backupBomb];
                 };

                 turnsToTake := turnsToTake - 1;
                 if: (turnsToTake <= 0) then: { advanceTurn(); };
                 result := "DEFUSED";
            };

            if: (type == "PLAYER_LEFT") then: {
                killPlayer(pid);
                def hand := getHand(pid);
                if: !(hand == nil) then: { discardPile := discardPile + hand; hands.remove(pid); };

                if: (activePlayers.length == 1) then: {
                    result := "WINNER";
                } else: {
                    result := "DIED";
                };
            };
            result;
        };

        def removeCardFromHand(pid, cardTemplate) {
            def hand := getHand(pid);
            def newHand := [];
            def removed := false;

            if: (hand != nil) then: {
                hand.each: { |card|
                    if: ((!removed).and: {card.type == cardTemplate.type}) then: {
                        removed := true;
                    } else: {
                        newHand := newHand + [card];
                    };
                };
                hands.put(pid, newHand);
            };
        };

        def passTurnNoDraw() {
            system.println("[PASS] Turn Pass (skip)");
            advanceTurn();
        };

        def advanceTurn() {
            currentPlayerIndex := (currentPlayerIndex + 1) % activePlayers.length;
            turnsToTake := nextTurnCount;
            nextTurnCount := 1;
            system.println("[TURN] Player " + getCurrentPlayer() + " (actions: " + turnsToTake + ")");
        };

        def killPlayer(pid) {
            def idxToRemove := -1;
            def i := 0;
            activePlayers.each: { |p| if: (p == pid) then: { idxToRemove := i; }; i := i + 1; };

            if: (idxToRemove > -1) then: {
                def newActive := [];
                activePlayers.each: { |p| if: (p != pid) then: { newActive := newActive + [p]; }; };
                activePlayers := newActive;

                deadPlayers := deadPlayers + [pid];

                if: (idxToRemove < currentPlayerIndex) then: { currentPlayerIndex := currentPlayerIndex - 1; };
                if: (currentPlayerIndex >= activePlayers.length) then: { currentPlayerIndex := 0; };

                turnsToTake := 1;
                nextTurnCount := 1;
                system.println("[DEAD] Player " + pid + " is DEAD.");
            };
        };
    };
  };
};